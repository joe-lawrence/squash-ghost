<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Squash Ghosting Configuration</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Flowbite CDN for accordion functionality -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/flowbite/2.3.0/flowbite.min.js"></script>
  <style>
    /* Custom font for a clean look */
    body {
      font-family: "Inter", sans-serif;
    }
    /* Style for range input thumb and track */
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #4f46e5; /* Indigo-600 */
      cursor: pointer;
      box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.3); /* Ring around thumb */
      transition: background 0.15s ease-in-out;
      margin-top: -6px; /* Adjust for vertical alignment */
    }
    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #4f46e5; /* Indigo-600 */
      cursor: pointer;
      box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.3);
      transition: background 0.15s ease-in-out;
    }
    input[type="range"]::-webkit-slider-runnable-track {
      width: 100%;
      height: 8px;
      background: #e5e7eb; /* Gray-200 */
      border-radius: 4px;
      cursor: pointer;
    }
    input[type="range"]::-moz-range-track {
      width: 100%;
      height: 8px;
      background: #e5e7eb; /* Gray-200 */
      border-radius: 4px;
      cursor: pointer;
    }
    input[type="range"]:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    input[type="range"]:disabled::-webkit-slider-thumb {
        background: #9ca3af; /* Gray-400 */
        box-shadow: none;
    }
    input[type="range"]:disabled::-moz-range-thumb {
        background: #9ca3af; /* Gray-400 */
        box-shadow: none;
    }
    /* Hide scrollbars for the main container but allow scrolling */
    #sequences-container::-webkit-scrollbar {
        display: none;
    }
    #sequences-container {
        -ms-overflow-style: none;  /* IE and Edge */
        scrollbar-width: none;  /* Firefox */
    }

    /* Fix for "sticky" button effect on iOS Safari */
    button {
      -webkit-tap-highlight-color: transparent;
    }

    /* Custom style for selected row */
    .selected-row {
        background-color: #e0e7ff; /* Light indigo for selection */
        border-left: 4px solid #4f46e5; /* Accent border */
    }
    .dark .selected-row {
        background-color: #374151; /* Darker gray for dark mode selection */
        border-left-color: #6366f1; /* Dark mode accent */
    }
  </style>
</head>
<body class="flex min-h-screen items-center justify-center p-4 bg-gray-100 dark:bg-gray-900 transition-colors duration-75">
  <div id="app-container" class="w-full">
    <!-- App Title -->
    <h1 id="app-title" class="text-4xl font-extrabold text-gray-900 dark:text-white text-center mb-8">Squash Ghoster</h1>

    <!-- Start Workout Button (visible in table view) -->
    <div id="start-workout-container" class="mb-6 hidden">
      <button id="start-workout-btn" class="w-full px-6 py-3 bg-green-600 text-white rounded-lg text-lg font-bold hover:bg-green-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105">
        Start (00:00)
      </button>
    </div>

    <!-- Workout View Container (New) -->
    <div id="workout-view-container" class="w-full h-full hidden flex flex-col">
        <div class="flex justify-center space-x-4 mb-6">
            <button id="pause-resume-workout-btn" class="px-6 py-3 bg-blue-600 text-white rounded-lg text-lg font-bold hover:bg-blue-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105">
                <span class="flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><rect width="4" height="16" x="14" y="4" rx="1"/><rect width="4" height="16" x="6" y="4" rx="1"/></svg>
                </span>
            </button>
            <button id="stop-workout-btn" class="px-6 py-3 bg-red-600 text-white rounded-lg text-lg font-bold hover:bg-red-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105">
                <span class="flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><rect width="18" height="18" x="3" y="3" rx="2"/></svg>
                </span>
            </button>
        </div>
        <h2 id="current-pattern-name" class="text-3xl font-bold text-center text-gray-800 dark:text-white mb-6 hidden"></h2> <!-- Hidden by default -->
        <!-- New wrapper for vertical centering -->
        <div class="flex-grow flex flex-col items-center justify-center">
            <p id="current-shot-display" class="text-6xl font-extrabold text-indigo-600 dark:text-indigo-400 mt-2 mb-10"></p>
            <div class="w-full bg-gray-200 rounded-full h-4 dark:bg-gray-700 mb-6">
                <div id="progress-bar" class="bg-green-600 h-4 rounded-full transition-all duration-100 ease-linear" style="width: 0%"></div>
            </div>
        </div>
    </div>

    <!-- Table View Container -->
    <div id="table-view-container" class="w-full rounded-xl bg-white p-6 shadow-lg dark:bg-gray-800">
        <h2 class="text-2xl font-bold text-gray-800 dark:text-white mb-6">Workout Patterns</h2>

        <div class="relative overflow-x-auto shadow-md sm:rounded-lg mb-6">
            <table class="w-full text-sm text-left rtl:text-right text-gray-500 dark:text-gray-400">
                <tbody id="patterns-table-body">
                    <!-- Pattern rows will be dynamically inserted here -->
                </tbody>
            </table>
        </div>

        <div class="flex justify-center space-x-4">
            <!-- Delete Pattern Toggle Button -->
            <button id="delete-pattern-toggle-btn" class="px-4 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600" data-state="off">
                <span class="flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M18 6 6 18M6 6l12 12"/></svg>
                </span>
            </button>
            <button id="move-pattern-toggle-btn" class="px-4 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600" data-state="off">
                <span class="flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="m7 15 5 5 5-5M7 9l5-5 5 5"/></svg>
                </span>
            </button>
            <button id="new-pattern-btn" class="px-4 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105">
                <span class="flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-plus-lg" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2"/></svg>
                </span>
            </button>
        </div>
    </div>

    <!-- Pattern Editor Container -->
    <div id="pattern-editor-container" class="w-full rounded-xl bg-white p-6 shadow-lg dark:bg-gray-800 hidden">
        <!-- Back to List Button -->
        <div class="mb-4">
            <button id="back-to-list-btn" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-arrow-left" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8"/></svg>
                <span class="text-sm">Back to List</span>
            </button>
        </div>

        <!-- This div will contain the dynamically generated sequences -->
        <div id="sequences-container" class="overflow-hidden">
            <!-- Sequence Template - Keep it hidden and clone for editing -->
            <div id="sequence-template" class="w-full max-w-2xl rounded-xl bg-white p-2 shadow-lg dark:bg-gray-800 hidden">
                <div class="space-y-4">
                    <!-- New editable pattern name - Left Justified -->
                    <h3 id="pattern-name-display" class="text-xl font-bold text-indigo-700 dark:text-indigo-300 mb-4 cursor-pointer"></h3>

                    <div id="accordion-color" data-accordion="collapse" data-active-classes="bg-blue-100 dark:bg-gray-800 text-blue-600 dark:text-white">
                        <!-- Options -->
                        <h2 id="accordion-heading-options">
                            <button type="button" class="flex w-full items-center justify-between gap-3 rounded-t-lg border border-b-0 border-gray-200 p-3 font-medium text-gray-500 hover:bg-blue-100 focus:ring-4 focus:ring-blue-200 rtl:text-right dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800 dark:focus:ring-blue-800" data-accordion-target="#accordion-body-options" aria-expanded="false" aria-controls="accordion-body-options">
                                <span class="flex items-center gap-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-list-ul" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M5 11.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m-3 1a1 1 0 1 0 0-2 1 1 0 0 0 0 2m0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2m0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2"/></svg>
                                    <span class="font-bold">Options - </span><span id="optionsCountDisplay" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                                </span>
                                <svg data-accordion-icon class="h-3 w-3 shrink-0" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5 5 1 1 5" /></svg>
                            </button>
                        </h2>
                        <div id="accordion-body-options" class="hidden" aria-labelledby="accordion-heading-options">
                            <div class="border-x border-t border-gray-200 p-3 dark:border-gray-700">
                                <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">Available shot locations or types</p>
                                <div>
                                    <textarea id="shotOptions" rows="4" class="block w-full rounded-lg border border-gray-300 bg-gray-50 p-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500"></textarea>
                                </div>
                            </div>
                        </div>

                        <!-- Narration -->
                        <h2 id="accordion-heading-narration">
                            <button type="button" class="flex w-full items-center justify-between gap-3 border border-b-0 border-gray-200 p-3 font-medium text-gray-500 hover:bg-blue-100 focus:ring-4 focus:ring-blue-200 rtl:text-right dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800 dark:focus:ring-blue-800" data-accordion-target="#accordion-narration-body" aria-expanded="false" aria-controls="accordion-narration-body">
                                <span class="flex items-center gap-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chat-left-text" viewBox="0 0 16 16"><path d="M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2z"/><path d="M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5M3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6m0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5"/></svg>
                                    <span class="font-bold">Narration - </span><span id="narrationDisplay" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                                </span>
                                <svg data-accordion-icon class="h-3 w-3 shrink-0" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5 5 1 1 5" /></svg>
                            </button>
                        </h2>
                        <div id="accordion-narration-body" class="hidden" aria-labelledby="accordion-heading-narration">
                            <div class="border-x border-t border-gray-200 p-3 dark:border-gray-700">
                                <div class="mb-4"><label class="inline-flex items-center"><input type="checkbox" id="announceShots" class="form-checkbox rounded text-blue-600 focus:ring-blue-500" /><span class="ml-2 text-gray-700 dark:text-gray-300">Announce shots</span></label></div>
                                <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">Optional message before pattern starts</p>
                                <textarea id="introMessage" rows="2" class="block w-full rounded-lg border border-gray-300 bg-gray-50 p-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500"></textarea>
                                <p class="mb-2 mt-4 text-sm font-normal text-gray-500 dark:text-gray-400">Optional message after pattern ends</p>
                                <textarea id="outroMessage" rows="2" class="block w-full rounded-lg border border-gray-300 bg-gray-50 p-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500"></textarea>
                            </div>
                        </div>

                        <!-- Sequencing -->
                        <h2 id="accordion-heading-sequencing">
                            <button type="button" class="flex w-full items-center justify-between gap-3 border border-b-0 border-gray-200 p-3 font-medium text-gray-500 hover:bg-blue-100 focus:ring-4 focus:ring-blue-200 rtl:text-right dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800 dark:focus:ring-blue-800" data-accordion-target="#accordion-sequencing-body" aria-expanded="false" aria-controls="accordion-sequencing-body">
                                <span class="flex items-center gap-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-bar-chart-steps" viewBox="0 0 16 16"><path d="M.5 0a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-1 0V.5A.5.5 0 0 1 .5 0M2 1.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-4a.5.5 0 0 1-.5-.5zm2 4a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-7a.5.5 0 0 1-.5-.5zm2 4a.5.5 0 0 1 .5-.5h6a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-6a.5.5 0 0 1-.5-.5zm2 4a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-7a.5.5 0 0 1-.5-.5z" /></svg>
                                    <span class="font-bold">Sequencing - </span><span id="sequencingOrderDisplay" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                                </span>
                                <svg data-accordion-icon class="h-3 w-3 shrink-0" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5 5 1 1 5" /></svg>
                            </button>
                        </h2>
                        <div id="accordion-sequencing-body" class="hidden" aria-labelledby="accordion-heading-sequencing">
                            <div class="border-x border-t border-gray-200 p-3 dark:border-gray-700">
                                <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">How to iterate through the pattern options</p>
                                <div class="mb-4 flex flex-wrap items-center justify-start space-x-4">
                                    <label class="inline-flex items-center"><input type="radio" name="seriesOrder" value="in-order" class="form-radio rounded-full text-blue-600 focus:ring-blue-500" /><span class="ml-2 text-gray-700 dark:text-gray-300">In order</span></label>
                                    <label class="inline-flex items-center"><input type="radio" name="seriesOrder" value="randomized" class="form-radio rounded-full text-blue-600 focus:ring-blue-500" /><span class="ml-2 text-gray-700 dark:text-gray-300">Randomized</span></label>
                                </div>
                            </div>
                        </div>

                        <!-- Interval -->
                        <h2 id="accordion-heading-interval">
                            <button type="button" class="flex w-full items-center justify-between gap-3 border border-b-0 border-gray-200 p-3 font-medium text-gray-500 hover:bg-blue-100 focus:ring-4 focus:ring-blue-200 rtl:text-right dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800 dark:focus:ring-blue-800" data-accordion-target="#accordion-interval-body" aria-expanded="false" aria-controls="accordion-interval-body">
                                <span class="flex items-center gap-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-bar-right" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M6 8a.5.5 0 0 0 .5.5h5.793l-2.147 2.146a.5.5 0 0 0 .708.708l3-3a.5.5 0 0 0 0-.708l-3-3a.5.5 0 0 0-.708.708L12.293 7.5H6.5A.5.5 0 0 0 6 8m-2.5 7a.5.5 0 0 1-.5-.5v-13a.5.5 0 0 1 1 0v13a.5.5 0 0 1-.5.5" /></svg>
                                    <span class="font-bold">Interval - </span><span id="intervalCombinedDisplay" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                                </span>
                                <svg data-accordion-icon class="h-3 w-3 shrink-0" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5 5 1 1 5" /></svg>
                            </button>
                        </h2>
                        <div id="accordion-interval-body" class="hidden" aria-labelledby="accordion-heading-interval">
                            <div class="border-x border-t border-gray-200 p-3 dark:border-gray-700">
                                <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">Time between each shot</p>
                                <input type="range" id="shotInterval" min="3.0" max="8.0" step="0.1" class="w-full accent-blue-600" />
                                <p class="mb-2 mt-4 text-sm font-normal text-gray-500 dark:text-gray-400">Shot interval fuzz</p>
                                <input type="range" id="randomOffset" min="0.0" max="1.0" step="0.1" class="w-full accent-blue-600" />
                                <p class="mb-2 mt-4 text-sm font-normal text-gray-500 dark:text-gray-400">Next shot announcement</p>
                                <input type="range" id="nextShotAnnouncement" min="0.0" max="7.0" step="0.1" class="w-full accent-blue-600" />
                            </div>
                        </div>

                        <!-- Limits -->
                        <h2 id="accordion-heading-limits">
                            <button type="button" class="flex w-full items-center justify-between gap-3 border border-b-0 border-gray-200 p-3 font-medium text-gray-500 hover:bg-blue-100 focus:ring-4 focus:ring-blue-200 rtl:text-right dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800 dark:focus:ring-blue-800" data-accordion-target="#accordion-limits-body" aria-expanded="false" aria-controls="accordion-limits-body">
                                <span class="flex items-center gap-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-123" viewBox="0 0 16 16"><path d="M2.873 11.297V4.142H1.699L0 5.379v1.137l1.64-1.18h.06v5.961zm3.213-5.09v-.063c0-.618.44-1.169 1.196-1.169.676 0 1.174.44 1.174 1.106 0 .624-.42 1.101-.807 1.526L4.99 10.553v.744h4.78v-.99H6.643v-.069L8.41 8.252c.65-.724 1.237-1.332 1.237-2.27C9.646 4.849 8.723 4 7.308 4c-1.573 0-2.36 1.064-2.36 2.15v.057zm6.559 1.883h.786c.823 0 1.374.481 1.379 1.179.01.707-.55 1.216-1.421 1.21-.77-.005-1.326-.419-1.379-.953h-1.095c.042 1.053.938 1.918 2.464 1.918 1.478 0 2.642-.839 2.62-2.144-.02-1.143-.922-1.651-1.551-1.714v-.063c.535-.09 1.347-.66 1.326-1.678-.026-1.053-.933-1.855-2.359-1.845-1.5.005-2.317.88-2.348 1.898h1.116c.032-.498.498-.944 1.206-.944.703 0 1.206.435 1.206 1.07.005.64-.504 1.106-1.2 1.106h-.75z"/></svg>
                                    <span class="font-bold">Limits - </span><span id="limitsDisplay" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                                </span>
                                <svg data-accordion-icon class="h-3 w-3 shrink-0" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5 5 1 1 5" /></svg>
                            </button>
                        </h2>
                        <div id="accordion-limits-body" class="hidden" aria-labelledby="accordion-heading-limits">
                            <div class="border-x border-t border-gray-200 p-3 dark:border-gray-700">
                                <div class="mb-4">
                                    <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">Pattern bounds</p>
                                    <select id="limitTypeSelect" class="block w-full rounded-lg border border-gray-300 bg-gray-50 p-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500">
                                        <option value="shot">Max Shots</option>
                                        <option value="time">Max Time</option>
                                    </select>
                                </div>
                                <input type="range" id="patternLimitSlider" min="0" max="100" class="w-full accent-blue-600 mt-2" />
                            </div>
                        </div>

                        <!-- Post Pattern Rest -->
                        <h2 id="accordion-heading-post-rest">
                            <button type="button" class="flex w-full items-center justify-between gap-3 border border-gray-200 p-3 font-medium text-gray-500 hover:bg-blue-100 focus:ring-4 focus:ring-blue-200 rtl:text-right dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800 dark:focus:ring-blue-800" data-accordion-target="#accordion-post-rest-body" aria-expanded="false" aria-controls="accordion-post-rest-body">
                                <span class="flex items-center gap-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-heart-pulse" viewBox="0 0 16 16"><path d="m8 2.748-.717-.737C5.6.281 2.514.878 1.4 3.053.918 3.995.78 5.323 1.508 7H.43c-2.128-5.697 4.165-8.83 7.394-5.857q.09.083.176.171a3 3 0 0 1 .176-.17c3.23-2.974 9.522.159 7.394 5.856h-1.078c.728-1.677.59-3.005.108-3.947C13.486.878 10.4.28 8.717 2.01zM2.212 10h1.315C4.593 11.183 6.05 12.458 8 13.795c1.949-1.337 3.407-2.612 4.473-3.795h1.315c-1.265 1.566-3.14 3.25-5.788 5-2.648-1.75-4.523-3.434-5.788-5"/><path d="M10.464 3.314a.5.5 0 0 0-.945.049L7.921 8.956 6.464 5.314a.5.5 0 0 0-.88-.091L3.732 8H.5a.5.5 0 0 0 0 1H4a.5.5 0 0 0 .416-.223l1.473-2.209 1.647 4.118a.5.5 0 0 0 .945-.049l1.598-5.593 1.457 3.642A.5.5 0 0 0 12 9h3.5a.5.5 0 0 0 0-1h-3.162z"/></svg>
                                    <span class="font-bold">Post Pattern Rest - </span><span id="postSequenceRestDisplay" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                                </span>
                                <svg data-accordion-icon class="h-3 w-3 shrink-0" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5 5 1 1 5" /></svg>
                            </button>
                        </h2>
                        <div id="accordion-post-rest-body" class="hidden rounded-b-lg border border-t-0 border-gray-200 p-3 dark:border-gray-700">
                            <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">Resting period after this pattern</p>
                            <input type="range" id="postSequenceRest" min="0" max="300" class="w-full accent-blue-600" />
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Centered row of icon buttons - For current pattern in editor -->
        <div class="flex justify-center space-x-4 mt-8">
            <button id="clone-btn" class="flex flex-col items-center p-1 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M15 12v6m-3-3h6"/><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>
                <span class="text-xs mt-1">Clone</span>
            </button>
            <button id="import-btn" class="flex flex-col items-center p-1 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2"/></svg>
                <span class="text-xs mt-1">Import</span>
            </button>
            <button id="save-btn" class="flex flex-col items-center p-1 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z"/><path d="M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7M7 3v4a1 1 0 0 0 1 1h7"/></svg>
                <span class="text-xs mt-1">Save</span>
            </button>
        </div>
    </div>


    <!-- Global Controls for all patterns -->
    <div id="global-controls" class="flex justify-center space-x-4 mt-8 hidden">
        <button id="load-all-btn" class="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 w-32">Load</button>
        <button id="save-all-btn" class="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 w-32">Save</button>
        <button id="reset-all-btn" class="px-6 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 w-32">Reset</button>
    </div>

    <!-- The Confirmation Modal (for delete/reset) -->
    <div id="confirmation-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 hidden">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm">
            <h3 id="modal-title" class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Confirm Deletion</h3>
            <p id="modal-text" class="text-sm text-gray-600 dark:text-gray-300 mb-6">Are you sure you want to delete this pattern? This action cannot be undone.</p>
            <div class="flex justify-end space-x-4">
                <button id="cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 dark:bg-gray-600 dark:text-gray-200 dark:hover:bg-gray-500">Cancel</button>
                <button id="confirm-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Delete</button>
            </div>
        </div>
    </div>

    <!-- Custom Alert Modal -->
    <div id="alert-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 hidden">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm">
            <h3 id="alert-title" class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Alert</h3>
            <p id="alert-message" class="text-sm text-gray-600 dark:text-gray-300 mb-6"></p>
            <div class="flex justify-end">
                <button id="alert-ok-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">OK</button>
            </div>
        </div>
    </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // --- STATE MANAGEMENT ---
      let sequences = [];
      let activeSequenceIndex = -1; // -1 means no sequence is actively being edited
      let selectedPatternId = null; // Store the ID of the selected row for focus tracking
      let isMoveModeOn = false; // State for move mode
      let isDeleteModeOn = false; // State for delete mode

      const tableViewContainer = document.getElementById('table-view-container');
      const patternEditorContainer = document.getElementById('pattern-editor-container');
      const sequencesContainer = document.getElementById('sequences-container');
      const sequenceTemplate = document.getElementById('sequence-template');
      const patternsTableBody = document.getElementById('patterns-table-body');
      const appContainer = document.getElementById('app-container');
      const globalControls = document.getElementById('global-controls');
      const movePatternToggleButton = document.getElementById('move-pattern-toggle-btn');
      const deletePatternToggleButton = document.getElementById('delete-pattern-toggle-btn');
      const startWorkoutButton = document.getElementById('start-workout-btn');
      const startWorkoutContainer = document.getElementById('start-workout-container');

      // --- New Workout View Elements ---
      const workoutViewContainer = document.getElementById('workout-view-container');
      const startWorkoutBtn = document.getElementById('start-workout-btn'); // Already exists
      const stopWorkoutBtn = document.getElementById('stop-workout-btn'); // New
      const pauseResumeWorkoutBtn = document.getElementById('pause-resume-workout-btn'); // NEW
      const currentShotDisplay = document.getElementById('current-shot-display'); // New
      const progressBar = document.getElementById('progress-bar'); // New
      const currentPatternNameDisplay = document.getElementById('current-pattern-name'); // New
      const appTitle = document.getElementById('app-title'); // Main app title

      // --- Web Audio API ---
      let audioContext = null;
      let beepDuration = 0.5; // Duration for single beeps

      // --- SVG Icons ---
      const PAUSE_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><rect width="4" height="16" x="14" y="4" rx="1"/><rect width="4" height="16" x="6" y="4" rx="1"/></svg>`;
      const PLAY_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="m6 3 14 9-14 9z"/></svg>`;
      const STOP_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><rect width="18" height="18" x="3" y="3" rx="2"/></svg>`;
      const REPLAY_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>`;
      const EXIT_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M13 3h6a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-6M3 3l9 9M3 9V3h6"/></svg>`;


      // --- UTILITY FUNCTIONS ---
      const formatTime = (totalSeconds) => {
        const roundedSeconds = Math.round(totalSeconds);

        if (roundedSeconds === 0) return 'None';

        const minutes = Math.floor(roundedSeconds / 60);
        const seconds = roundedSeconds % 60;

        const formattedMinutes = minutes < 10 ? `0${minutes}` : `${minutes}`;
        const formattedSeconds = seconds < 10 ? `0${seconds}` : `${seconds}`;

        // Removed the "Time:" and "min/sec" suffix for a cleaner display as per request
        return `${formattedMinutes}:${formattedSeconds}`;
      };

      const getNewSequenceData = () => {
        const defaultShotOptions = 'Front left\nFront right\nMid left\nMid right\nBack left\nBack right';
        const defaultShotOptionsCount = defaultShotOptions.trim().split(/[\n,]+/).filter(Boolean).length;
        const defaultShotInterval = 4.0;

        return {
          id: Date.now() + Math.random(),
          patternName: 'New Pattern',
          shotOptions: defaultShotOptions,
          announceShots: true,
          introMessage: '',
          outroMessage: '',
          seriesOrder: 'in-order',
          shotInterval: defaultShotInterval,
          randomOffset: 0.0,
          nextShotAnnouncement: 1.25,
          limitType: 'shot', // Default to 'shot'
          patternLimit: defaultShotOptionsCount, // Default to shotOptions count for Max Shots
          postSequenceRest: 0,
          previousShotLimit: defaultShotOptionsCount, // Initialize with default shots
          previousTimeLimit: defaultShotOptionsCount * defaultShotInterval // Initialize with default time
        };
      };

      const focusOnTop = () => {
        if(appContainer) {
          appContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      };

      // Helper for sanitizing filenames
      const sanitizeFilename = (name) => {
        return name.replace(/[^a-z0-9\s-]/gi, '').replace(/\s+/g, '-');
      };

      // Sanity check for a single pattern configuration
      const isValidPatternConfig = (data) => {
        const requiredProps = [
          'patternName', 'shotOptions', 'announceShots', 'introMessage', 'outroMessage',
          'seriesOrder', 'shotInterval', 'randomOffset', 'nextShotAnnouncement', 'limitType', 'patternLimit', 'postSequenceRest'
        ];
        const hasAllProps = requiredProps.every(prop => Object.prototype.hasOwnProperty.call(data, prop));

        if (!hasAllProps) return false;

        // Basic type checking
        if (typeof data.patternName !== 'string' ||
            typeof data.shotOptions !== 'string' ||
            typeof data.announceShots !== 'boolean' ||
            typeof data.introMessage !== 'string' ||
            typeof data.outroMessage !== 'string' ||
            !['in-order', 'randomized'].includes(data.seriesOrder) ||
            typeof data.shotInterval !== 'number' ||
            typeof data.randomOffset !== 'number' ||
            typeof data.nextShotAnnouncement !== 'number' ||
            !['shot', 'time'].includes(data.limitType) ||
            typeof data.patternLimit !== 'number' ||
            typeof data.postSequenceRest !== 'number') {
            return false;
        }

        return true;
      };

      // Sanity check for an entire workout file (array of patterns)
      const isValidWorkoutFile = (data) => {
        if (!Array.isArray(data)) {
            return false;
        }
        return data.every(pattern => isValidPatternConfig(pattern));
      };

      // Custom Alert Modal
      const alertModal = document.getElementById('alert-modal');
      const alertTitle = document.getElementById('alert-title');
      const alertMessage = document.getElementById('alert-message');
      const alertOkBtn = document.getElementById('alert-ok-btn');

      const showAlert = (title, message) => {
          alertTitle.textContent = title;
          alertMessage.textContent = message;
          alertModal.classList.remove('hidden');
          alertOkBtn.onclick = () => {
              alertModal.classList.add('hidden');
          };
      };

      // Function to set interaction mode (move, delete, or null for off)
      const setInteractionMode = (mode) => {
          const wasMoveModeOn = isMoveModeOn;
          const wasDeleteModeOn = isDeleteModeOn;

          isMoveModeOn = (mode === 'move');
          isDeleteModeOn = (mode === 'delete');

          // Update toggle button visuals
          movePatternToggleButton.classList.toggle('bg-blue-600', isMoveModeOn);
          movePatternToggleButton.classList.toggle('text-white', isMoveModeOn);
          movePatternToggleButton.classList.toggle('bg-gray-200', !isMoveModeOn);
          movePatternToggleButton.classList.toggle('text-gray-700', !isMoveModeOn);
          movePatternToggleButton.classList.toggle('dark:bg-gray-700', !isMoveModeOn);
          movePatternToggleButton.classList.toggle('dark:text-gray-300', !isMoveModeOn);
          movePatternToggleButton.dataset.state = isMoveModeOn ? 'on' : 'off';

          deletePatternToggleButton.classList.toggle('bg-red-600', isDeleteModeOn);
          deletePatternToggleButton.classList.toggle('text-white', isDeleteModeOn);
          deletePatternToggleButton.classList.toggle('bg-gray-200', !isDeleteModeOn);
          deletePatternToggleButton.classList.toggle('text-gray-700', !isDeleteModeOn);
          deletePatternToggleButton.classList.toggle('dark:bg-gray-700', !isDeleteModeOn);
          deletePatternToggleButton.classList.toggle('dark:text-gray-300', !isDeleteModeOn);
          deletePatternToggleButton.dataset.state = isDeleteModeOn ? 'on' : 'off';

          // Only re-render table and toggle other buttons if a mode state actually changed
          if (wasMoveModeOn !== isMoveModeOn || wasDeleteModeOn !== isDeleteModeOn) {
              renderTableView(); // Re-render table to show/hide specific buttons
              toggleOtherButtons(); // Apply global disabling based on new mode state
          }
      };

      // Function to disable/enable other buttons and elements based on active mode
      const toggleOtherButtons = () => {
          const disableAllMainActions = isMoveModeOn || isDeleteModeOn;

          const newPatternBtn = document.getElementById('new-pattern-btn');
          const loadAllBtn = document.getElementById('load-all-btn');
          const saveAllBtn = document.getElementById('save-all-btn');
          const resetAllBtn = document.getElementById('reset-all-btn');
          const startWorkoutBtn = document.getElementById('start-workout-btn');

          const backToListBtn = document.getElementById('back-to-list-btn');
          const cloneBtn = document.getElementById('clone-btn');
          const importBtn = document.getElementById('import-btn');
          const saveBtn = document.getElementById('save-btn');

          // Buttons affected by any active mode (excluding the mode's own toggle and global reset)
          const elementsToToggleDisable = [
              newPatternBtn, loadAllBtn, saveAllBtn, startWorkoutBtn,
              backToListBtn, cloneBtn, importBtn, saveBtn
          ];

          elementsToToggleDisable.forEach(element => {
              if (element) {
                  element.disabled = disableAllMainActions;
                  if (disableAllMainActions) {
                      element.classList.add('opacity-50', 'cursor-not-allowed');
                  } else {
                      element.classList.remove('opacity-50', 'cursor-not-allowed');
                  }
              }
          });

          // Specific handling for mode toggle buttons (mutually exclusive)
          if (movePatternToggleButton) {
              movePatternToggleButton.disabled = isDeleteModeOn;
              if (isDeleteModeOn) {
                  movePatternToggleButton.classList.add('opacity-50', 'cursor-not-allowed');
              } else {
                  movePatternToggleButton.classList.remove('opacity-50', 'cursor-not-allowed');
              }
          }
          if (deletePatternToggleButton) {
              deletePatternToggleButton.disabled = isMoveModeOn;
              if (isMoveModeOn) {
                  deletePatternToggleButton.classList.add('opacity-50', 'cursor-not-allowed');
              } else {
                  deletePatternToggleButton.classList.remove('opacity-50', 'cursor-not-allowed');
              }
          }

          // Global Reset button is special, it's never disabled by these modes
          if (resetAllBtn) {
            resetAllBtn.disabled = false;
            resetAllBtn.classList.remove('opacity-50', 'cursor-not-allowed');
          }

          // Handle delete buttons and pattern names in table rows
          patternsTableBody.querySelectorAll('.delete-pattern-btn').forEach(button => {
              // Delete button in row should only be enabled when delete mode is ON
              button.disabled = !isDeleteModeOn;
              if (!isDeleteModeOn) {
                  button.classList.add('opacity-50', 'cursor-not-allowed');
              } else {
                  button.classList.remove('opacity-50', 'cursor-not-allowed');
              }
          });

          patternsTableBody.querySelectorAll('.pattern-name-clickable').forEach(span => {
              // If any mode is on, pattern name should not be clickable to enter editor
              if (disableAllMainActions) {
                  span.classList.remove('cursor-pointer');
                  span.style.pointerEvents = 'none';
              } else {
                  span.classList.add('cursor-pointer');
                  span.style.pointerEvents = 'auto';
              }
          });

          // Disable/enable elements inside the editor if it's visible
          if (!patternEditorContainer.classList.contains('hidden')) {
              const currentEl = sequencesContainer.firstChild; // Get the currently active cloned sequence element
              if (currentEl) {
                  // Accordion buttons and input fields inside the editor
                  currentEl.querySelectorAll('#accordion-color button[data-accordion-target]').forEach(accordionBtn => {
                      accordionBtn.disabled = disableAllMainActions;
                      accordionBtn.classList.toggle('opacity-50', disableAllMainActions);
                      accordionBtn.classList.toggle('cursor-not-allowed', disableAllMainActions);
                  });

                  currentEl.querySelectorAll('input:not([type="hidden"]), textarea, select').forEach(inputField => {
                      const isInternallyDisabled = (inputField.id === 'nextShotAnnouncement' && !currentEl.querySelector('#announceShots').checked);
                      inputField.disabled = disableAllMainActions || isInternallyDisabled;
                      inputField.classList.toggle('opacity-50', disableAllMainActions || isInternallyDisabled);
                      inputField.classList.toggle('cursor-not-allowed', disableAllMainActions || isInternallyDisabled);
                  });

                  const patternNameDisplay = currentEl.querySelector('#pattern-name-display');
                  if (patternNameDisplay) {
                    if (disableAllMainActions) {
                        patternNameDisplay.classList.remove('cursor-pointer');
                        patternNameDisplay.style.pointerEvents = 'none';
                    } else {
                        patternNameDisplay.classList.add('cursor-pointer');
                        patternNameDisplay.style.pointerEvents = 'auto';
                    }
                  }
              }
          }
      };


      // --- VIEW MANAGEMENT ---
      const showView = (view) => {
          // Clear dynamic classes from appContainer and body first
          appContainer.className = 'w-full'; // Reset appContainer to base classes
          document.body.classList.remove('items-center', 'justify-center'); // Remove body centering

          // Hide all view containers initially
          tableViewContainer.classList.add('hidden');
          startWorkoutContainer.classList.add('hidden');
          patternEditorContainer.classList.add('hidden');
          globalControls.classList.add('hidden');
          workoutViewContainer.classList.add('hidden');
          appTitle.classList.remove('hidden'); // Ensure app title is visible by default

          if (view === 'table' || view === 'editor') {
              appContainer.classList.add('max-w-2xl', 'rounded-xl', 'bg-white', 'p-6', 'shadow-lg', 'dark:bg-gray-800');
              document.body.classList.add('items-center', 'justify-center'); // Center appContainer in body
              // Show specific containers
              if (view === 'table') {
                  tableViewContainer.classList.remove('hidden');
                  startWorkoutContainer.classList.remove('hidden');
                  globalControls.classList.remove('hidden');
                  renderTableView();
                  calculateTotalWorkoutTime();
              } else { // editor
                  patternEditorContainer.classList.remove('hidden');
                  renderPatternEditor();
              }
              focusOnTop();
              setInteractionMode(null); // Ensure modes are off when entering non-workout views
          } else if (view === 'workout') {
              // For workout, appContainer takes full height and manages its own content centering
              appContainer.classList.add('min-h-screen', 'flex', 'flex-col', 'items-center', 'justify-center', 'p-4');
              appTitle.classList.add('hidden'); // Hide main app title during workout

              workoutViewContainer.classList.remove('hidden');
              focusOnTop();
          }
      };

      // --- ESTIMATED WORKOUT TIME CALCULATION ---
      const calculateTotalWorkoutTime = () => {
          let totalTime = 0;
          sequences.forEach(pattern => {
              let patternDuration = 0;

              // limitType will always be 'shot' or 'time'
              if (pattern.limitType === 'time') {
                  patternDuration = pattern.patternLimit;
              } else if (pattern.limitType === 'shot') {
                  patternDuration = pattern.patternLimit * pattern.shotInterval;
              }
              totalTime += patternDuration;
              totalTime += pattern.postSequenceRest;
          });
          startWorkoutButton.textContent = `Start (${formatTime(totalTime)})`;
      };


      // --- TABLE VIEW RENDERING ---
      const renderTableView = () => {
          patternsTableBody.innerHTML = '';
          if (sequences.length === 0) {
              const noPatternsRow = document.createElement('tr');
              noPatternsRow.classList.add('bg-white', 'dark:bg-gray-800');
              noPatternsRow.innerHTML = `<td colspan="2" class="px-6 py-4 text-center text-gray-500 dark:text-gray-400">No patterns configured. Click "New Pattern" to add one.</td>`;
              patternsTableBody.appendChild(noPatternsRow);
              return;
          }

          sequences.forEach((pattern, index) => {
              const row = document.createElement('tr');
              row.dataset.patternId = pattern.id; // Add pattern ID to the row for easier identification
              row.classList.add('bg-white', 'border-b', 'dark:bg-gray-800', 'dark:border-gray-700', 'hover:bg-gray-50', 'dark:hover:bg-gray-600');
              row.dataset.index = index; // Store the index for easy access

              // Apply 'selected-row' class if this pattern is currently selected
              if (pattern.id === selectedPatternId) {
                  row.classList.add('selected-row');
              }

              row.innerHTML = `
                  <td class="px-4 py-3 whitespace-nowrap">
                      <div class="flex items-center space-x-2">
                          <div class="flex flex-row items-center space-x-1 ${isMoveModeOn ? '' : 'hidden'}"> <!-- Conditional visibility for move buttons -->
                              <button class="up-arrow-btn p-1 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 ${index === 0 ? 'opacity-30 cursor-not-allowed' : ''}" ${index === 0 ? 'disabled' : ''}>
                                  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="m18 15-6-6-6 6"/></svg>
                              </button>
                              <button class="down-arrow-btn p-1 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 ${index === sequences.length - 1 ? 'opacity-30 cursor-not-allowed' : ''}" ${index === sequences.length - 1 ? 'disabled' : ''}>
                                  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="m6 9 6 6 6-6"/></svg>
                              </button>
                          </div>
                          <span class="pattern-name-clickable flex-grow font-bold text-base text-indigo-700 dark:text-indigo-300 cursor-pointer">${pattern.patternName}</span>
                      </div>
                  </td>
                  <td class="px-4 py-3 text-right">
                      <button class="delete-pattern-btn p-1 rounded-full hover:bg-red-200 dark:hover:bg-red-800 text-red-600 dark:text-red-400 ${isDeleteModeOn ? '' : 'hidden'}"> <!-- Conditional visibility for delete button -->
                          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M18 6 6 18M6 6l12 12"/></svg>
                      </button>
                      <button class="view-pattern-btn p-1 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 ${!isDeleteModeOn && !isMoveModeOn ? '' : 'hidden'}">
                          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M20 7h-9m3 10H5"/><circle cx="17" cy="17" r="3"/><circle cx="7" cy="7" r="3"/></svg>
                      </button>
                  </td>
              `;
              patternsTableBody.appendChild(row);
          });

          // After rendering, if there's a selected pattern, ensure its row is visible
          if (selectedPatternId) {
              const selectedRow = patternsTableBody.querySelector(`[data-pattern-id="${selectedPatternId}"]`);
              if (selectedRow) {
                  selectedRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
              }
          }
          // Ensure other buttons are toggled correctly after rendering
          toggleOtherButtons();
      };

      // --- PATTERN EDITOR RENDERING & DATA SYNC ---
      const renderPatternEditor = () => {
        sequencesContainer.innerHTML = '';
        if (activeSequenceIndex === -1 || sequences.length === 0) {
            // This state should ideally not be reached if logic correctly hides editor when no pattern is active
            showView('table');
            return;
        }

        const currentData = sequences[activeSequenceIndex];
        const newSequenceEl = sequenceTemplate.cloneNode(true);
        newSequenceEl.id = `sequence-${currentData.id}`;
        newSequenceEl.classList.remove('hidden');
        sequencesContainer.appendChild(newSequenceEl);

        const patternNameDisplay = newSequenceEl.querySelector('#pattern-name-display');
        const shotOptions = newSequenceEl.querySelector('#shotOptions');
        const announceShots = newSequenceEl.querySelector('#announceShots');
        const introMessage = newSequenceEl.querySelector('#introMessage');
        const outroMessage = newSequenceEl.querySelector('#outroMessage');
        const seriesOrderRadios = newSequenceEl.querySelectorAll('input[name="seriesOrder"]');
        const shotInterval = newSequenceEl.querySelector('#shotInterval');
        const randomOffset = newSequenceEl.querySelector('#randomOffset');
        const nextShotAnnouncement = newSequenceEl.querySelector('#nextShotAnnouncement');
        const limitTypeSelect = newSequenceEl.querySelector('#limitTypeSelect');
        const patternLimitSlider = newSequenceEl.querySelector('#patternLimitSlider');
        const postSequenceRest = newSequenceEl.querySelector('#postSequenceRest');

        patternNameDisplay.textContent = currentData.patternName;
        shotOptions.value = currentData.shotOptions;
        announceShots.checked = currentData.announceShots;
        introMessage.value = currentData.introMessage;
        outroMessage.value = currentData.outroMessage;
        seriesOrderRadios.forEach(radio => radio.checked = radio.value === currentData.seriesOrder);
        shotInterval.value = currentData.shotInterval;
        randomOffset.value = currentData.randomOffset;
        nextShotAnnouncement.value = currentData.nextShotAnnouncement;
        limitTypeSelect.value = currentData.limitType;
        patternLimitSlider.value = currentData.patternLimit;
        postSequenceRest.value = currentData.postSequenceRest;

        updateAllDisplays(newSequenceEl);
        handleLimitTypeChange(newSequenceEl); // Re-run to ensure slider values/min/max are correct
        handleAnnounceShotsChange(newSequenceEl);
        initFlowbite(); // Re-initialize Flowbite for new accordion elements

        patternNameDisplay.addEventListener('click', () => editPatternName(currentData, patternNameDisplay));
        toggleOtherButtons(); // Apply state after view change
      };

      const saveCurrentSequenceState = () => {
        if (activeSequenceIndex === -1 || sequences.length === 0) return;

        const currentData = sequences[activeSequenceIndex];
        const currentEl = sequencesContainer.firstChild; // The cloned template is always the first child
        if (!currentEl) return;

        // Save the current patternLimit to the appropriate 'previous' field before updating currentData
        if (currentData.limitType === 'shot') {
            currentData.previousShotLimit = parseInt(currentEl.querySelector('#patternLimitSlider').value);
        } else if (currentData.limitType === 'time') {
            currentData.previousTimeLimit = parseInt(currentEl.querySelector('#patternLimitSlider').value);
        }

        currentData.shotOptions = currentEl.querySelector('#shotOptions').value;
        currentData.announceShots = currentEl.querySelector('#announceShots').checked;
        currentData.introMessage = currentEl.querySelector('#introMessage').value;
        currentData.outroMessage = currentEl.querySelector('#outroMessage').value;
        currentData.seriesOrder = currentEl.querySelector('input[name="seriesOrder"]:checked').value;
        currentData.shotInterval = parseFloat(currentEl.querySelector('#shotInterval').value);
        currentData.randomOffset = parseFloat(currentEl.querySelector('#randomOffset').value);
        currentData.nextShotAnnouncement = parseFloat(currentEl.querySelector('#nextShotAnnouncement').value);
        currentData.limitType = currentEl.querySelector('#limitTypeSelect').value;
        currentData.patternLimit = parseInt(currentEl.querySelector('#patternLimitSlider').value);
        currentData.postSequenceRest = parseInt(currentEl.querySelector('#postSequenceRest').value);

        calculateTotalWorkoutTime();
      };

      // --- UI UPDATE FUNCTIONS ---
      const updateAllDisplays = (context) => {
          updateShotOptionsDisplay(context);
          updateNarrationDisplay(context);
          updateSequencingDisplay(context);
          updateIntervalDisplay(context);
          updateLimitsDisplay(context);
          updatePostRestDisplay(context);
      }

      const updateShotOptionsDisplay = (context) => {
        const shotOptions = context.querySelector('#shotOptions');
        const display = context.querySelector('#optionsCountDisplay');
        const count = shotOptions.value.trim().split(/[\n,]+/).filter(Boolean).length;
        display.textContent = `${count} shots`;
      };

      const updateNarrationDisplay = (context) => {
        const display = context.querySelector('#narrationDisplay');
        const parts = [];
        if (context.querySelector('#announceShots').checked) parts.push('Shots');
        if (context.querySelector('#introMessage').value.trim()) parts.push('Intro');
        if (context.querySelector('#outroMessage').value.trim()) parts.push('Outro');
        display.textContent = parts.length ? parts.join(', ') : 'None';
      };

      const updateSequencingDisplay = (context) => {
          const display = context.querySelector('#sequencingOrderDisplay');
          const value = context.querySelector('input[name="seriesOrder"]:checked').value;
          display.textContent = value === 'in-order' ? 'In order' : 'Randomized';
      };

      const updateIntervalDisplay = (context) => {
        const display = context.querySelector('#intervalCombinedDisplay');
        const interval = parseFloat(context.querySelector('#shotInterval').value).toFixed(1);
        const offset = parseFloat(context.querySelector('#randomOffset').value).toFixed(1);
        const nextShotAnnounce = parseFloat(context.querySelector('#nextShotAnnouncement').value).toFixed(1);

        let text = offset > 0 ? `${interval} sec  ${offset}` : `${interval} sec`;
        if (context.querySelector('#announceShots').checked) {
            text += ` (${nextShotAnnounce}s)`;
        }
        display.textContent = text;
      };

      const handleLimitTypeChange = (context) => {
        const select = context.querySelector('#limitTypeSelect');
        const slider = context.querySelector('#patternLimitSlider');
        const currentPattern = sequences[activeSequenceIndex];
        const newLimitType = select.value;
        const oldLimitType = currentPattern.limitType;

        // Save the current patternLimit to the appropriate 'previous' field before updating currentPattern.limitType
        if (oldLimitType === 'shot') {
            currentPattern.previousShotLimit = parseInt(context.querySelector('#patternLimitSlider').value);
        } else if (oldLimitType === 'time') {
            currentPattern.previousTimeLimit = parseInt(context.querySelector('#patternLimitSlider').value);
        }

        slider.disabled = false;

        if (newLimitType === 'shot') {
            slider.min = 0;
            slider.max = 100;
            // Restore previous shot limit, or calculate default if not available/valid
            let proposedValue = currentPattern.previousShotLimit;
            // If no stored value, or it's 0 (invalid for default), or if switching from time-based default to shot
            if (typeof proposedValue !== 'number' || proposedValue <= 0 || oldLimitType === 'time') {
                const shotOptionsCount = currentPattern.shotOptions.trim().split(/[\n,]+/).filter(Boolean).length;
                proposedValue = shotOptionsCount; // Default to current shot options count
            }
            slider.value = Math.min(Math.max(proposedValue, parseInt(slider.min)), parseInt(slider.max));

        } else if (newLimitType === 'time') {
            const shotOptionsCount = currentPattern.shotOptions.trim().split(/[\n,]+/).filter(Boolean).length;
            const estimatedTimeForOptions = shotOptionsCount * currentPattern.shotInterval;

            slider.min = Math.max(1, Math.round(currentPattern.shotInterval)); // Minimum of 1s or rounded interval
            slider.max = 1800; // 30 minutes in seconds

            // Restore previous time limit, or calculate default if not available/valid
            let proposedValue = currentPattern.previousTimeLimit;
            // If no stored value, or it's 0 (invalid for default), or if switching from shot-based default to time
            if (typeof proposedValue !== 'number' || proposedValue <= 0 || oldLimitType === 'shot') {
                 proposedValue = Math.round(estimatedTimeForOptions); // Default to calculated time
            }
            slider.value = Math.min(Math.max(proposedValue, parseInt(slider.min)), parseInt(slider.max));
        }

        // Update the current pattern's limitType and patternLimit in the state
        currentPattern.limitType = newLimitType;
        currentPattern.patternLimit = parseInt(slider.value);

        updateLimitsDisplay(context);
        calculateTotalWorkoutTime();
      };

      const handleAnnounceShotsChange = (context) => {
          const announceShotsCheckbox = context.querySelector('#announceShots');
          const nextShotAnnouncementSlider = context.querySelector('#nextShotAnnouncement');
          const shotIntervalSlider = context.querySelector('#shotInterval');

          nextShotAnnouncementSlider.disabled = !announceShotsCheckbox.checked;

          if (announceShotsCheckbox.checked) {
              const currentShotInterval = parseFloat(shotIntervalSlider.value);
              nextShotAnnouncementSlider.max = Math.max(0.0, currentShotInterval - 0.1);
              if (parseFloat(nextShotAnnouncementSlider.value) > nextShotAnnouncementSlider.max) {
                  nextShotAnnouncementSlider.value = nextShotAnnouncementSlider.max;
              }
              if (parseFloat(nextShotAnnouncementSlider.value) === 0 && nextShotAnnouncementSlider.max >= 1.25) {
                nextShotAnnouncementSlider.value = 1.25;
              }
          } else {
              nextShotAnnouncementSlider.value = 0;
          }
          updateIntervalDisplay(context);
      };

      const updateLimitsDisplay = (context) => {
        const display = context.querySelector('#limitsDisplay');
        const type = context.querySelector('#limitTypeSelect').value;
        const value = parseInt(context.querySelector('#patternLimitSlider').value);
        if (type === 'shot') {
          display.textContent = `${value} shots`;
        } else if (type === 'time') {
          display.textContent = formatTime(value);
        }
      };

      const updatePostRestDisplay = (context) => {
        const display = context.querySelector('#postSequenceRestDisplay');
        const value = parseInt(context.querySelector('#postSequenceRest').value);
        display.textContent = formatTime(value);
      };


      // --- SEQUENCE MANAGEMENT FUNCTIONS ---
      const addSequence = () => {
        // Save current pattern state ONLY if in editor view
        if (!patternEditorContainer.classList.contains('hidden')) {
            saveCurrentSequenceState();
        }

        const newSequence = getNewSequenceData();
        newSequence.patternName = `Pattern ${sequences.length + 1}`;
        sequences.push(newSequence);

        // Re-render the current view to reflect the added pattern
        if (tableViewContainer.classList.contains('hidden')) { // If currently in editor view
            renderPatternEditor();
        } else { // If in table view
            selectedPatternId = newSequence.id; // Select the newly added pattern
            renderTableView();
        }
        calculateTotalWorkoutTime();
        focusOnTop();
      };

      const cloneSequence = () => {
        if (activeSequenceIndex === -1) {
            showAlert('Clone Error', 'No pattern selected to clone.');
            return;
        }
        saveCurrentSequenceState(); // Always save current state when cloning

        const currentData = sequences[activeSequenceIndex];
        const clonedData = JSON.parse(JSON.stringify(currentData));
        clonedData.id = Date.now() + Math.random();
        clonedData.patternName = `${clonedData.patternName} (Clone)`;
        sequences.splice(activeSequenceIndex + 1, 0, clonedData);

        // Re-render the current view to reflect the added pattern
        if (tableViewContainer.classList.contains('hidden')) { // If currently in editor view
            activeSequenceIndex++; // Increment index so the cloned item appears after the current one
            renderPatternEditor(); // Re-render the new current pattern (which is now the cloned one)
        } else { // If currently in table view
            renderTableView(); // Re-render the table
        }
        calculateTotalWorkoutTime();
        focusOnTop();
      };

      const movePattern = (index, direction) => {
          const patternIdToSelect = sequences[index].id;

          if (direction === 'up' && index > 0) {
              [sequences[index], sequences[index - 1]] = [sequences[index - 1], sequences[index]];
              // activeSequenceIndex also needs to be updated if the moved pattern was the active one
              if (activeSequenceIndex === index) activeSequenceIndex--;
              else if (activeSequenceIndex === index - 1) activeSequenceIndex++;
          } else if (direction === 'down' && index < sequences.length - 1) {
              [sequences[index], sequences[index + 1]] = [sequences[index + 1], sequences[index]];
              // activeSequenceIndex also needs to be updated if the moved pattern was the active one
              if (activeSequenceIndex === index) activeSequenceIndex++;
              else if (activeSequenceIndex === index + 1) activeSequenceIndex--;
          }
          selectedPatternId = patternIdToSelect; // Set the ID of the pattern to be selected
          renderTableView();
          calculateTotalWorkoutTime();
      };

      const deleteSequence = (indexToDelete) => {
          // If only one pattern, clear and reset instead of deleting entirely
          if (sequences.length <= 1) {
              const currentPatternId = sequences.length > 0 ? sequences[0].id : null;
              sequences = []; // Clear array
              sequences.push({ ...getNewSequenceData(), id: currentPatternId }); // Add new default, keeping old ID if exists
              sequences[0].patternName = "Pattern 1"; // Reset name
              activeSequenceIndex = 0; // The single pattern becomes active at index 0
              selectedPatternId = sequences[0].id; // Select the reset pattern
              showAlert('Pattern Reset', 'Last pattern reset to default settings.');
              if (patternEditorContainer.classList.contains('hidden')) {
                  showView('table'); // Ensure table view is rendered to show the single pattern
              } else {
                  renderPatternEditor(); // Re-render editor with reset pattern
              }
              calculateTotalWorkoutTime();
              return;
          }

          // Save active pattern's state BEFORE modification if it's the one being deleted
          if (activeSequenceIndex === indexToDelete) {
              saveCurrentSequenceState();
          }

          sequences.splice(indexToDelete, 1);

          // Adjust activeSequenceIndex based on the deletion
          if (activeSequenceIndex === indexToDelete) {
              // If the deleted item was the active one
              activeSequenceIndex = Math.max(0, indexToDelete - 1); // Move to previous, or 0 if first was deleted
              if (sequences.length === 0) activeSequenceIndex = -1; // No patterns left
          } else if (activeSequenceIndex > indexToDelete) {
              // If an item *before* the active one was deleted
              activeSequenceIndex--;
          }

          selectedPatternId = activeSequenceIndex !== -1 ? sequences[activeSequenceIndex].id : null;

          // Decide which view to render
          if (sequences.length === 0 || activeSequenceIndex === -1) {
              showView('table'); // No patterns or no active pattern, go to table
          } else {
              renderPatternEditor(); // Re-render the new active sequence in editor
          }
          calculateTotalWorkoutTime();
          focusOnTop();
      };


      const resetCurrentSequence = () => {
          if (activeSequenceIndex === -1 || sequences.length === 0) return;
          const currentId = sequences[activeSequenceIndex].id;
          sequences[activeSequenceIndex] = { ...getNewSequenceData(), id: currentId };
          sequences[activeSequenceIndex].patternName = `Pattern ${activeSequenceIndex + 1}`;
          selectedPatternId = sequences[activeSequenceIndex].id; // Ensure the reset pattern is selected
          renderPatternEditor();
          calculateTotalWorkoutTime();
      };

      const showSequenceInEditor = (index) => {
          if (index < 0 || index >= sequences.length) return;
          if (activeSequenceIndex !== -1) { // Only save if there was an active sequence
             saveCurrentSequenceState(); // Save current state before switching
          }
          activeSequenceIndex = index;
          selectedPatternId = sequences[index].id; // Set the selected pattern ID
          showView('editor');
      };

      // Function to handle pattern name editing
      const editPatternName = (currentData, displayElement) => {
          setInteractionMode(null);

          const inputElement = document.createElement('input');
          inputElement.type = 'text';
          inputElement.value = currentData.patternName;
          inputElement.className = 'text-xl font-bold text-indigo-700 dark:text-indigo-300 w-full bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md p-1';

          displayElement.parentNode.replaceChild(inputElement, displayElement);
          inputElement.focus();

          const saveAndRevert = () => {
              let newName = inputElement.value.trim();
              if (newName === '') {
                  newName = 'Unnamed Pattern';
              }
              currentData.patternName = newName;
              renderPatternEditor(); // Re-render to show updated label
              calculateTotalWorkoutTime();
          };

          inputElement.addEventListener('blur', saveAndRevert);
          inputElement.addEventListener('keydown', (e) => {
              if (e.key === 'Enter') {
                  saveAndRevert();
                  inputElement.blur();
              }
          });
      };

      // --- INDIVIDUAL PATTERN IMPORT / SAVE FUNCTIONS ---
      const savePatternConfig = () => {
        setInteractionMode(null);
        if (activeSequenceIndex === -1 || sequences.length === 0) {
          showAlert('Save Error', 'No pattern selected to save.');
          return;
        }
        saveCurrentSequenceState();
        const currentPattern = sequences[activeSequenceIndex];
        const dataStr = JSON.stringify(currentPattern, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `${sanitizeFilename(currentPattern.patternName)}.pattern.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showAlert('Pattern Saved', `Pattern "${currentPattern.patternName}" saved successfully.`);
        calculateTotalWorkoutTime();
      };

      const importPatternConfig = () => {
        setInteractionMode(null);

        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json,.pattern.json';
        fileInput.style.display = 'none';

        fileInput.addEventListener('change', (event) => {
          const file = event.target.files[0];
          if (!file) {
              document.body.removeChild(fileInput);
              return;
          }

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const importedData = JSON.parse(e.target.result);
              if (isValidPatternConfig(importedData)) {
                if (activeSequenceIndex !== -1) {
                    // Overwrite current active pattern
                    const currentPatternId = sequences[activeSequenceIndex].id;
                    sequences[activeSequenceIndex] = {
                      ...importedData,
                      id: currentPatternId,
                    };
                    selectedPatternId = sequences[activeSequenceIndex].id;
                    renderPatternEditor();
                    showAlert('Pattern Imported', `Pattern "${importedData.patternName}" imported successfully.`);
                } else {
                    // Add as a new pattern if no pattern is active in editor
                    importedData.id = Date.now() + Math.random();
                    sequences.push(importedData);
                    activeSequenceIndex = sequences.length - 1;
                    selectedPatternId = importedData.id;
                    showView('editor');
                    showAlert('Pattern Imported', `Pattern "${importedData.patternName}" added as new pattern.`);
                }
                calculateTotalWorkoutTime();
              } else {
                showAlert('Import Error', 'Invalid pattern configuration file. Please select a valid .pattern.json file.');
              }
            } catch (error) {
              showAlert('Import Error', 'Failed to parse file. Please ensure it is a valid JSON file.');
            } finally {
              document.body.removeChild(fileInput);
            }
          };
          reader.onerror = () => {
            showAlert('Import Error', 'Failed to read file.');
            document.body.removeChild(fileInput);
          };
          reader.readAsText(file);
        });

        document.body.appendChild(fileInput);
        fileInput.click();
      };

      // --- GLOBAL WORKOUT (ALL PATTERNS) FUNCTIONS ---
      const loadAllPatterns = () => {
        setInteractionMode(null);

        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json,.workout.json';
        fileInput.style.display = 'none';

        fileInput.addEventListener('change', (event) => {
          const file = event.target.files[0];
          if (!file) {
              document.body.removeChild(fileInput);
              return;
          }

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const importedWorkout = JSON.parse(e.target.result);
              if (isValidWorkoutFile(importedWorkout)) {
                sequences = importedWorkout.map(pattern => ({ ...pattern, id: Date.now() + Math.random() }));
                activeSequenceIndex = -1; // Go back to table view
                selectedPatternId = null; // Clear selection when loading all
                showView('table');
                showAlert('Workout Loaded', `Successfully loaded ${sequences.length} patterns.`);
                calculateTotalWorkoutTime();
              } else {
                showAlert('Load Error', 'Invalid workout file. Please select a valid .workout.json file containing an array of patterns.');
              }
            } catch (error) {
              showAlert('Load Error', 'Failed to parse workout file. Please ensure it is a valid JSON file.');
            } finally {
              document.body.removeChild(fileInput);
            }
          };
          reader.onerror = () => {
            showAlert('Load Error', 'Failed to read workout file.');
            document.body.removeChild(fileInput);
          };
          reader.readAsText(file);
        });

        document.body.appendChild(fileInput);
        fileInput.click();
      };

      const saveAllPatterns = () => {
        setInteractionMode(null);
        // If in editor view, save current pattern before saving all
        if (!patternEditorContainer.classList.contains('hidden')) {
          saveCurrentSequenceState();
        }

        if (sequences.length === 0) {
            showAlert('Save Error', 'No patterns to save in the workout file.');
            return;
        }
        const dataStr = JSON.stringify(sequences, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `my-workout-${new Date().toISOString().slice(0,10)}.workout.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showAlert('Workout Saved', `Successfully saved ${sequences.length} patterns to a workout file.`);
        calculateTotalWorkoutTime();
      };

      const clearAllPatterns = () => {
          setInteractionMode(null);

          const modal = document.getElementById('confirmation-modal');
          const modalTitle = document.getElementById('modal-title');
          const modalText = document.getElementById('modal-text');
          const confirmBtn = document.getElementById('confirm-btn');
          const cancelBtn = document.getElementById('cancel-btn');

          modalTitle.textContent = 'Confirm Reset';
          modalText.textContent = 'Are you sure you want to clear all workout patterns? This action cannot be undone.';
          confirmBtn.textContent = 'Reset';
          confirmBtn.className = 'px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700';
          modal.classList.remove('hidden');

          const onConfirm = () => {
              sequences = [];
              sequences.push(getNewSequenceData());
              sequences[0].patternName = "Pattern 1";
              activeSequenceIndex = -1; // Reset to table view
              selectedPatternId = null; // Clear selection
              showView('table');
              modal.classList.add('hidden');
              confirmBtn.removeEventListener('click', onConfirm);
              cancelBtn.removeEventListener('click', onCancel);
              calculateTotalWorkoutTime();
          };

          const onCancel = () => {
              modal.classList.add('hidden');
              confirmBtn.removeEventListener('click', onConfirm);
              cancelBtn.removeEventListener('click', onCancel);
          };

          confirmBtn.addEventListener('click', onConfirm);
          cancelBtn.addEventListener('click', onCancel);
      };

    // --- Workout Logic (NEW) ---
    let currentPatternIndex = 0;
    let currentPatternTimer = null; // Timer for individual shot intervals
    let shotIntervalTimer = null; // General interval timer (used for rest periods)
    let flashTimer = null; // Timer for screen flash
    let currentPatternShotCount = 0;
    let currentPatternTimeElapsed = 0;
    let currentShotOptions = [];
    let currentShotIndex = 0;
    let globalWorkoutTimeElapsed = 0; // Not currently used for display but good for tracking

    let isPaused = false; // NEW: State for pause/resume
    let pausedTimePassed = 0; // NEW: To store timePassed when paused
    let pausedEffectiveInterval = 0; // NEW: To store effectiveInterval when paused
    let pausedRestTimeRemaining = 0; // NEW: To store rest time remaining when paused


    /**
     * Initializes the Web Audio API context.
     * Crucially, this function attempts to resume the AudioContext on the first user interaction
     * to comply with browser autoplay policies, especially on mobile (e.g., iOS Safari).
     */
    function initAudioContext() {
        try {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                // If the audio context is suspended (common on iOS), attempt to resume it
                // when the user interacts with the document (e.g., clicks the start button).
                if (audioContext.state === 'suspended') {
                    const resumeAudio = () => {
                        audioContext.resume().then(() => {
                            console.log('AudioContext resumed successfully.');
                            // Remove listeners once resumed to avoid multiple calls
                            document.removeEventListener('click', resumeAudio);
                            document.removeEventListener('touchend', resumeAudio);
                        }).catch(error => console.error("Error resuming AudioContext:", error));
                    };
                    // Add passive listeners for user gestures
                    document.addEventListener('click', resumeAudio, { once: true, passive: true });
                    document.addEventListener('touchend', resumeAudio, { once: true, passive: true });
                }
            }
        } catch (error) {
            console.error("Failed to initialize AudioContext:", error);
        }
    }

    /**
     * Plays a two-tone beep sound for shot announcements.
     * Consists of a lower tone followed by a higher tone.
     */
    function playTwoToneBeep() {
        try {
            if (!audioContext || audioContext.state === 'suspended') {
                console.warn("AudioContext not ready for two-tone beep.");
                return;
            }

            const duration = 0.15; // Shorter duration for quick beeps
            const frequency1 = 800; // First tone (e.g., F5)
            const frequency2 = 1200; // Second tone (e.g., D6)
            const volume = 0.8; // Slightly lower volume for the beeps

            // First tone
            const oscillator1 = audioContext.createOscillator();
            const gainNode1 = audioContext.createGain();
            oscillator1.connect(gainNode1);
            gainNode1.connect(audioContext.destination);
            oscillator1.type = 'sine';
            oscillator1.frequency.setValueAtTime(frequency1, audioContext.currentTime);
            gainNode1.gain.setValueAtTime(volume, audioContext.currentTime);
            oscillator1.start(audioContext.currentTime);
            gainNode1.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration);
            oscillator1.stop(audioContext.currentTime + duration);

            // Second tone, delayed to start after the first one finishes
            const oscillator2 = audioContext.createOscillator();
            const gainNode2 = audioContext.createGain();
            oscillator2.connect(gainNode2);
            gainNode2.connect(audioContext.destination);
            oscillator2.type = 'sine';
            oscillator2.frequency.setValueAtTime(frequency2, audioContext.currentTime + duration); // Start second tone after first
            gainNode2.gain.setValueAtTime(volume, audioContext.currentTime + duration);
            oscillator2.start(audioContext.currentTime + duration);
            gainNode2.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration * 2); // Total duration
            oscillator2.stop(audioContext.currentTime + duration * 2);
        } catch (error) {
            console.error("Error playing two-tone beep:", error);
        }
    }


    function startWorkout() {
        if (sequences.length === 0) {
            showAlert('Workout Error', 'Please create at least one workout pattern first!');
            return;
        }

        // Save current editor state before starting workout
        if (!patternEditorContainer.classList.contains('hidden')) {
            saveCurrentSequenceState();
        }

        // Initialize audio context on user interaction
        initAudioContext();
        if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                console.log('AudioContext resumed for workout start.');
            }).catch(error => console.error("Error resuming AudioContext at startWorkout:", error));
        }

        // Reset the stop button to its initial state (stop icon)
        stopWorkoutBtn.innerHTML = `<span class="flex items-center justify-center">${STOP_ICON}</span>`;
        stopWorkoutBtn.onclick = stopWorkout; // Re-attach the stopWorkout handler
        stopWorkoutBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
        stopWorkoutBtn.classList.add('bg-red-600', 'hover:bg-red-700');


        // Ensure pause/resume button is visible and shows pause icon
        pauseResumeWorkoutBtn.innerHTML = `<span class="flex items-center justify-center">${PAUSE_ICON}</span>`;
        // Ensure its click handler is the togglePauseResume function
        pauseResumeWorkoutBtn.onclick = togglePauseResume;
        pauseResumeWorkoutBtn.classList.remove('hidden');


        showView('workout'); // Switch to workout display
        currentPatternIndex = 0;
        globalWorkoutTimeElapsed = 0;
        isPaused = false; // Ensure not paused when starting
        runCurrentPattern(); // Start the first pattern
    }

    function stopWorkout() {
        clearInterval(currentPatternTimer);
        clearInterval(shotIntervalTimer);
        clearTimeout(flashTimer);
        document.body.classList.remove('bg-red-500'); // Only remove the color class
        showView('table'); // Return to main menu
        calculateTotalWorkoutTime(); // Recalculate total time (might not change, but good practice)
    }

    function togglePauseResume() {
        if (isPaused) {
            resumeWorkout();
        } else {
            pauseWorkout();
        }
    }

    function pauseWorkout() {
        isPaused = true;
        clearInterval(currentPatternTimer); // Stop current shot timer
        clearInterval(shotIntervalTimer); // Stop rest timer if active
        clearTimeout(flashTimer); // Clear any pending flash
        document.body.classList.remove('bg-red-500'); // Ensure flash is off

        pauseResumeWorkoutBtn.innerHTML = `<span class="flex items-center justify-center">${PLAY_ICON}</span>`;
        currentShotDisplay.textContent = 'Paused'; // Indicate paused state
        // Update progress bar to show current paused progress
        progressBar.style.width = `${(pausedTimePassed / pausedEffectiveInterval) * 100}%`;
    }

    function resumeWorkout() {
        isPaused = false;
        pauseResumeWorkoutBtn.innerHTML = `<span class="flex items-center justify-center">${PAUSE_ICON}</span>`;

        if (currentShotDisplay.textContent === 'Rest!') { // If paused during rest
            const currentPattern = sequences[currentPatternIndex];
            // Restart rest timer from remaining time
            shotIntervalTimer = setInterval(() => {
                if (isPaused) { // Check for pause again
                    clearInterval(shotIntervalTimer);
                    return;
                }
                pausedRestTimeRemaining -= 1; // Decrement from remaining time
                globalWorkoutTimeElapsed += 1;
                // The next line seems to be a copy-paste error; it should likely use pausedRestTimeRemaining directly
                // pausedRestTimeRemaining = postRestTime - restElapsed; // Update remaining for pause
                if (pausedRestTimeRemaining <= 0) {
                    clearInterval(shotIntervalTimer);
                    currentPatternIndex++;
                    runCurrentPattern();
                }
            }, 1000);
            currentShotDisplay.textContent = 'Rest!'; // Restore rest text
        } else { // If paused during a shot interval
            const currentPattern = sequences[currentPatternIndex];
            // Resume the shot countdown from where it left off
            startShotInterval(currentPattern, pausedTimePassed, pausedEffectiveInterval);
        }
    }


    function runCurrentPattern() {
        if (currentPatternIndex >= sequences.length) {
            // All patterns completed
            handleWorkoutCompletion();
            return;
        }

        const currentPattern = sequences[currentPatternIndex];
        // currentPatternNameDisplay.textContent = currentPattern.patternName; // Pattern name is now hidden
        currentShotOptions = currentPattern.shotOptions.split('\n').filter(option => option.trim() !== '');

        // Handle randomized order: shuffle options for current pattern
        if (currentPattern.seriesOrder === 'randomized') {
            shuffleArray(currentShotOptions);
        }
        currentShotIndex = 0; // Reset shot index for new pattern
        currentPatternShotCount = 0; // Reset shot count for new pattern
        currentPatternTimeElapsed = 0; // Reset time elapsed for new pattern

        // Announce intro message if available
        if (currentPattern.announceShots && currentPattern.introMessage.trim()) {
            speak(currentPattern.introMessage);
        }

        // Start the interval for shots
        startShotInterval(currentPattern);
    }

    // Modified startShotInterval to accept optional `initialTimePassed` and `totalInterval` for resuming
    function startShotInterval(pattern, initialTimePassed = 0, totalInterval = -1) {
        if (isPaused) return; // Do not start if paused

        clearInterval(currentPatternTimer); // Clear any previous interval for this pattern's shots
        clearInterval(shotIntervalTimer); // Clear any general interval (e.g., from a rest period)

        let baseInterval = parseFloat(pattern.shotInterval);
        let randomOffset = parseFloat(pattern.randomOffset);
        let nextShotAnnouncementTime = parseFloat(pattern.nextShotAnnouncement);

        let effectiveInterval = (totalInterval > 0) ? totalInterval : (baseInterval + (Math.random() * randomOffset));
        let timePassed = initialTimePassed; // Use initialTimePassed for resuming

        pausedEffectiveInterval = effectiveInterval; // Store for pause/resume

        function executeShot() {
            if (isPaused) return; // Prevent execution if paused

            // Check if pattern limits are met before executing the next shot
            if (shouldEndPattern(pattern)) {
                endPattern(pattern);
                return;
            }

            // Display current shot
            if (currentShotOptions.length > 0) {
                const shotToDisplay = currentShotOptions[currentShotIndex];
                currentShotDisplay.textContent = shotToDisplay;
                if (pattern.announceShots) {
                    speak(shotToDisplay);
                }
                currentShotIndex = (currentShotIndex + 1) % currentShotOptions.length;
                // If randomized, and we've cycled through all options, reshuffle
                if (pattern.seriesOrder === 'randomized' && currentShotIndex === 0) {
                    shuffleArray(currentShotOptions);
                }
            } else {
                currentShotDisplay.textContent = 'No shots defined for this pattern';
                endPattern(pattern); // Consider ending pattern if no shots are defined
                return;
            }

            // Play two-tone beep and flash screen red ONLY if not paused
            if (!isPaused) {
                playTwoToneBeep(); // Play the two-tone beep
                flashScreenRed(); // Flash the screen red
            }

            currentPatternShotCount++;

            // Set up next shot timer with random offset
            effectiveInterval = baseInterval + (Math.random() * randomOffset); // Recalculate for next shot
            timePassed = 0; // Reset for new shot

            pausedEffectiveInterval = effectiveInterval; // Update for pause/resume

            clearInterval(currentPatternTimer); // Clear previous timer for this shot
            currentPatternTimer = setInterval(() => {
                if (isPaused) {
                    clearInterval(currentPatternTimer); // Stop timer if paused
                    pausedTimePassed = timePassed; // Store current timePassed
                    return;
                }
                timePassed += 0.1; // Update every 100ms
                currentPatternTimeElapsed += 0.1;
                globalWorkoutTimeElapsed += 0.1;

                // Update progress bar
                const progress = (timePassed / effectiveInterval) * 100;
                progressBar.style.width = `${progress}%`;

                // Announce next shot if applicable (speech is handled by separate 'speak' call)
                // This block is primarily for visual cues if needed, the actual speech is scheduled below
                if (pattern.announceShots && nextShotAnnouncementTime > 0 &&
                    effectiveInterval - timePassed <= nextShotAnnouncementTime + 0.05 &&
                    effectiveInterval - timePassed > (nextShotAnnouncementTime - 0.1)
                    ) {
                    // No action needed here, speech is handled in `executeShot`'s delayed `speak` call.
                }

                if (timePassed >= effectiveInterval) {
                    clearInterval(currentPatternTimer);
                    executeShot(); // Move to the next shot
                }
            }, 100); // Update every 100ms for smoother progress bar
        }

        if (initialTimePassed === 0) { // Only execute a new shot if not resuming from a specific time
            executeShot(); // Start the first shot for the current pattern immediately or after a completed pause
        } else { // If resuming, continue current shot
            currentPatternTimer = setInterval(() => {
                if (isPaused) {
                    clearInterval(currentPatternTimer);
                    pausedTimePassed = timePassed;
                    return;
                }
                timePassed += 0.1;
                currentPatternTimeElapsed += 0.1;
                globalWorkoutTimeElapsed += 0.1;

                const progress = (timePassed / effectiveInterval) * 100;
                progressBar.style.width = `${progress}%`;

                if (pattern.announceShots && nextShotAnnouncementTime > 0 &&
                    effectiveInterval - timePassed <= nextShotAnnouncementTime + 0.05 &&
                    effectiveInterval - timePassed > (nextShotAnnouncementTime - 0.1)
                    ) {
                    // No action needed here, speech is handled in `executeShot`'s delayed `speak` call.
                }

                if (timePassed >= effectiveInterval) {
                    clearInterval(currentPatternTimer);
                    executeShot();
                }
            }, 100);
        }
    }


    function shouldEndPattern(pattern) {
        if (pattern.limitType === 'shot' && currentPatternShotCount >= pattern.patternLimit) {
            return true;
        }
        if (pattern.limitType === 'time' && currentPatternTimeElapsed >= pattern.patternLimit) {
            return true;
        }
        return false;
    }

    function endPattern(pattern) {
        clearInterval(currentPatternTimer);
        clearInterval(shotIntervalTimer);
        clearTimeout(flashTimer);
        document.body.classList.remove('bg-red-500'); // Ensure flash is off

        // Announce outro message if available
        if (pattern.announceShots && pattern.outroMessage.trim()) {
            speak(pattern.outroMessage);
        }

        // Handle post-pattern rest
        const postRestTime = parseInt(pattern.postSequenceRest);
        if (postRestTime > 0) {
            currentShotDisplay.textContent = "Rest!";
            progressBar.style.width = '100%'; // Full progress bar for rest

            let restElapsed = 0;
            pausedRestTimeRemaining = postRestTime; // Store for pause/resume

            shotIntervalTimer = setInterval(() => {
                if (isPaused) { // Check for pause again
                    clearInterval(shotIntervalTimer);
                    return;
                }
                restElapsed += 1; // Update every second
                globalWorkoutTimeElapsed += 1;
                pausedRestTimeRemaining = postRestTime - restElapsed; // Update remaining for pause
                if (restElapsed >= postRestTime) {
                    clearInterval(shotIntervalTimer);
                    currentPatternIndex++;
                    runCurrentPattern(); // Move to the next pattern
                }
            }, 1000); // Update every second for rest countdown
        } else {
            currentPatternIndex++;
            runCurrentPattern(); // Move to the next pattern immediately if no rest
        }
    }

    function handleWorkoutCompletion() {
        clearInterval(currentPatternTimer);
        clearInterval(shotIntervalTimer);
        clearTimeout(flashTimer);
        document.body.classList.remove('bg-red-500');

        currentShotDisplay.textContent = 'Done';
        progressBar.style.width = '100%';

        // Pause/Resume button becomes Replay
        pauseResumeWorkoutBtn.innerHTML = `<span class="flex items-center justify-center">${REPLAY_ICON}</span>`;
        pauseResumeWorkoutBtn.onclick = null; // Clear existing click handler
        pauseResumeWorkoutBtn.addEventListener('click', () => {
            currentPatternIndex = 0; // Reset pattern index for full workout replay
            startWorkout();
        }, { once: true }); // Add new handler, remove after one use
        pauseResumeWorkoutBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
        pauseResumeWorkoutBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');

        // Stop button becomes Exit to Main Menu
        stopWorkoutBtn.innerHTML = `<span class="flex items-center justify-center">${EXIT_ICON}</span>`;
        stopWorkoutBtn.onclick = null; // Clear existing click handler
        stopWorkoutBtn.addEventListener('click', stopWorkout, { once: true }); // stopWorkout already shows table view
        stopWorkoutBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
        stopWorkoutBtn.classList.add('bg-gray-600', 'hover:bg-gray-700'); // Use a neutral color for exit

        // Do not show "Workout Complete" dialog
    }


    function flashScreenRed() {
        if (isPaused) return; // Do not flash if paused
        document.body.classList.add('bg-red-500'); // Only add the color class
        // Force reflow to ensure the class change is rendered before timeout
        void document.body.offsetWidth; // Accessing offsetWidth triggers reflow
        flashTimer = setTimeout(() => {
            document.body.classList.remove('bg-red-500'); // Only remove the color class
        }, 150); // Flash for 150ms
    }

    function speak(text) {
        if ('speechSynthesis' in window) {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US'; // Set desired language
            window.speechSynthesis.speak(utterance);
        } else {
            console.warn('Speech Synthesis API not supported in this browser.');
        }
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

      // --- EVENT LISTENERS ---

      // Global click listener to turn off modes if an unrelated element is clicked
      document.addEventListener('click', (e) => {
          // Only turn off modes if a mode is currently ON
          if (isMoveModeOn || isDeleteModeOn) {
              // Check if the click target is NOT one of the interactive mode-related elements
              if (e.target !== movePatternToggleButton &&
                  !movePatternToggleButton.contains(e.target) &&
                  e.target !== deletePatternToggleButton &&
                  !deletePatternToggleButton.contains(e.target) &&
                  !patternsTableBody.contains(e.target) &&
                  !e.target.closest('#confirmation-modal') &&
                  !e.target.closest('#alert-modal') &&
                  e.target !== startWorkoutButton &&
                  !startWorkoutButton.contains(e.target) &&
                  !patternEditorContainer.contains(e.target) &&
                  !workoutViewContainer.contains(e.target) // Also exclude workout view
              ) {
                  setInteractionMode(null); // Turn off all modes
              }
          }
      });


      // Table View Buttons
      document.getElementById('new-pattern-btn').addEventListener('click', () => {
        setInteractionMode(null);
        addSequence();
      });

      movePatternToggleButton.addEventListener('click', () => {
          setInteractionMode(isMoveModeOn ? null : 'move');
      });

      deletePatternToggleButton.addEventListener('click', () => {
          setInteractionMode(isDeleteModeOn ? null : 'delete');
      });


      // Event delegation for table body clicks
      patternsTableBody.addEventListener('click', (e) => {
          const row = e.target.closest('tr');
          if (!row) return;

          const index = parseInt(row.dataset.index);
          const patternId = sequences[index].id;

          patternsTableBody.querySelectorAll('tr').forEach(r => r.classList.remove('selected-row'));
          row.classList.add('selected-row');
          selectedPatternId = patternId; // Update the globally selected pattern ID

          if (e.target.closest('.up-arrow-btn')) {
              movePattern(index, 'up');
              e.target.closest('button')?.blur();
              e.stopPropagation();
          } else if (e.target.closest('.down-arrow-btn')) {
              movePattern(index, 'down');
              e.target.closest('button')?.blur();
              e.stopPropagation();
          } else if (e.target.closest('.delete-pattern-btn')) {
              if (isDeleteModeOn) {
                  const modal = document.getElementById('confirmation-modal');
                  const modalTitle = document.getElementById('modal-title');
                  const modalText = document.getElementById('modal-text');
                  const confirmBtn = document.getElementById('confirm-btn');
                  const cancelBtn = document.getElementById('cancel-btn');

                  modalTitle.textContent = 'Confirm Deletion';
                  modalText.textContent = `Are you sure you want to delete pattern "${sequences[index].patternName}"? This action cannot be undone.`;
                  confirmBtn.textContent = 'Delete';
                  confirmBtn.className = 'px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700';
                  modal.classList.remove('hidden');
                  e.target.closest('button')?.blur();

                  // Clear previous listeners and add new ones for the specific action
                  confirmBtn.replaceWith(confirmBtn.cloneNode(true));
                  cancelBtn.replaceWith(cancelBtn.cloneNode(true));
                  const newConfirmBtn = document.getElementById('confirm-btn');
                  const newCancelBtn = document.getElementById('cancel-btn');

                  newConfirmBtn.addEventListener('click', () => {
                      deleteSequence(index);
                      modal.classList.add('hidden');
                      focusOnTop();
                  });
                  newCancelBtn.addEventListener('click', () => modal.classList.add('hidden'));
                  e.stopPropagation();
              } else {
                  setInteractionMode(null);
              }
          } else if (e.target.closest('.pattern-name-clickable') || e.target.closest('.view-pattern-btn')) {
              setInteractionMode(null);
              showSequenceInEditor(index);
          }
      });


      // Pattern Editor Buttons
      document.getElementById('clone-btn').addEventListener('click', () => {
          setInteractionMode(null);
          cloneSequence();
          document.getElementById('clone-btn').blur();
      });
      document.getElementById('import-btn').addEventListener('click', () => {
          setInteractionMode(null);
          importPatternConfig();
          document.getElementById('import-btn').blur();
      });
      document.getElementById('save-btn').addEventListener('click', () => {
          setInteractionMode(null);
          savePatternConfig();
          document.getElementById('save-btn').blur();
      });


      // Back to List button in editor
      document.getElementById('back-to-list-btn').addEventListener('click', () => {
          setInteractionMode(null);
          saveCurrentSequenceState();
          activeSequenceIndex = -1;
          showView('table');
          selectedPatternId = null;
      });

      // Global buttons for all patterns
      document.getElementById('load-all-btn').addEventListener('click', loadAllPatterns);
      document.getElementById('save-all-btn').addEventListener('click', saveAllPatterns);
      document.getElementById('reset-all-btn').addEventListener('click', clearAllPatterns);

      // --- New Workout Buttons Event Listeners ---
      startWorkoutBtn.addEventListener('click', startWorkout);
      // Event listener for stopWorkoutBtn is dynamically added/removed in startWorkout/handleWorkoutCompletion
      pauseResumeWorkoutBtn.addEventListener('click', togglePauseResume);


      // Event listeners for inputs/changes within the currently rendered sequence editor
      sequencesContainer.addEventListener('input', (e) => {
          if (!patternEditorContainer.classList.contains('hidden') && sequencesContainer.contains(e.target)) {
              const currentEl = sequencesContainer.firstChild;
              if (!currentEl) return;

              if (e.target.closest('#limitTypeSelect')) {
                  handleLimitTypeChange(currentEl);
              } else {
                  saveCurrentSequenceState();
              }

              if (e.target.closest('#shotOptions')) updateShotOptionsDisplay(currentEl);
              if (e.target.closest('#introMessage') || e.target.closest('#outroMessage')) updateNarrationDisplay(currentEl);
              if (e.target.closest('#shotInterval') || e.target.closest('#randomOffset') || e.target.closest('#nextShotAnnouncement')) {
                  updateIntervalDisplay(currentEl);
                  // Recalculate limit if type is time and interval changed
                  if (sequences[activeSequenceIndex].limitType === 'time') {
                     handleLimitTypeChange(currentEl); // This will re-evaluate patternLimit based on new interval
                  }
                  // Also re-evaluate nextShotAnnouncement max if shotInterval changes
                  if (e.target.closest('#shotInterval')) {
                    handleAnnounceShotsChange(currentEl); // Update max for nextShotAnnouncement based on new interval
                  }
              }
              if (e.target.closest('#patternLimitSlider')) updateLimitsDisplay(currentEl);
              if (e.target.closest('#postSequenceRest')) updatePostRestDisplay(currentEl);
          }
      });
      sequencesContainer.addEventListener('change', (e) => {
          if (!patternEditorContainer.classList.contains('hidden') && sequencesContainer.contains(e.target)) {
              const currentEl = sequencesContainer.firstChild;
              if (!currentEl) return;

              if (e.target.closest('#limitTypeSelect')) {
                  handleLimitTypeChange(currentEl);
              } else {
                  saveCurrentSequenceState();
              }
              
              if (e.target.name === 'seriesOrder') updateSequencingDisplay(currentEl);
              if (e.target.closest('#announceShots')) handleAnnounceShotsChange(currentEl);
          }
      });


      // --- INITIALIZATION ---
      const initialize = () => {
        // Ensure sequences array is not empty on initial load
        if (sequences.length === 0) {
            sequences.push(getNewSequenceData());
            sequences[0].patternName = "Pattern 1";
        }
        activeSequenceIndex = -1; // Ensure no pattern is active on initial load
        selectedPatternId = sequences[0].id; // Select the first pattern by default
        showView('table'); // Start with the table view
        toggleOtherButtons(); // Ensure all other buttons are enabled initially
        calculateTotalWorkoutTime(); // Initial calculation of total time

        // Initialize audio context on initial page load or first user interaction
        initAudioContext();
      };

      initialize();
    });
  </script>
</body>
</html>

