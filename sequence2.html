<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Squash Ghoster</title>

  <!-- iOS Web App Meta Tags -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <link rel="icon" href="favicon.ico" sizes="32x32">
  <link rel="manifest" href="manifest.webmanifest">

  <!-- Tailwind CSS CDN: https://cdn.tailwindcss.com -->
  <script src="tailwindcss.js"></script>
  <!-- Flowbite CDN for accordion functionality: https://cdnjs.cloudflare.com/ajax/libs/flowbite/2.3.0/flowbite.min.js -->
  <script src="flowbite.min.js"></script>

  <style>
    /* Custom font for a clean look */
    body {
      font-family: "Inter", sans-serif;
      /* This ensures direct changes to background-color are instant,
         overriding any transition-colors from Tailwind for this property. */
      transition: background-color 0s !important;
    }
    /* Style for range input thumb and track */
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #4f46e5; /* Indigo-600 */
      cursor: pointer;
      box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.3); /* Ring around thumb */
      transition: background 0.15s ease-in-out;
      margin-top: -6px; /* Adjust for vertical alignment */
    }
    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #4f46e5; /* Indigo-600 */
      cursor: pointer;
      box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.3);
      transition: background 0.15s ease-in-out;
    }
    input[type="range"]::-webkit-slider-runnable-track {
      width: 100%;
      height: 8px;
      background: #e5e7eb; /* Gray-200 */
      border-radius: 4px;
      cursor: pointer;
    }
    input[type="range"]::-moz-range-track {
      width: 100%;
      height: 8px;
      background: #e5e7eb; /* Gray-200 */
      border-radius: 4px;
      cursor: pointer;
    }
    input[type="range"]:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    input[type="range"]:disabled::-webkit-slider-thumb {
        background: #9ca3af; /* Gray-400 */
        box-shadow: none;
    }
    input[type="range"]:disabled::-moz-range-thumb {
        background: #9ca3af; /* Gray-400 */
        box-shadow: none;
    }
    /* Hide scrollbars for the main container but allow scrolling */
    #sequences-container::-webkit-scrollbar {
        display: none;
    }
    #sequences-container {
        -ms-overflow-style: none;  /* IE and Edge */
        scrollbar-width: none;  /* Firefox */
    }

    /* Fix for "sticky" button effect on iOS Safari */
    button {
      -webkit-tap-highlight-color: transparent;
    }

    /* Custom style for selected row - REMOVED LEFT BORDER */
    .selected-row {
        background-color: #e0e7ff; /* Light indigo for selection */
    }
    .dark .selected-row {
        background-color: #374151; /* Darker gray for dark mode selection */
    }

    /* Style for dropdown arrows */
    select {
        border: 2px solid #cbd5e0;
        transition: border-color 0.2s ease-in-out;
        background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='none' stroke='%234A5568'%3e%3cpath d='M7 7l3-3 3 3m0 6l-3 3-3-3' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3e%3c/svg%3e"); /* Custom arrow */
        background-repeat: no-repeat;
        background-position: right 0.75rem center;
        background-size: 1.5em 1.5em;
        padding-right: 2.5rem; /* Make space for the arrow */
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
    }
    select:focus {
        outline: none;
        border-color: #6366f1;
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
    }
  </style>
</head>
<body class="flex min-h-screen items-center justify-center p-4 bg-gray-100 dark:bg-gray-900 transition-colors duration-75">

  <div id="app-container" class="w-full">
    <!-- App Title -->
    <div id="app-banner-container" class="text-center mb-8">
      <img id="app-banner" src="" alt="Squash Ghoster" class="mx-auto w-full max-w-md h-auto">
    </div>

    <!-- Start Workout Button (visible in main view) -->
    <div id="start-workout-container" class="mb-6 hidden">
      <button id="start-workout-btn" class="w-full px-6 py-3 bg-green-600 text-white rounded-lg text-lg font-bold hover:bg-green-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105">
        Start (00:00)
      </button>
    </div>

    <!-- Workout View Container -->
    <div id="workout-view-container" class="w-full h-full hidden flex flex-col">
        <!-- Buttons at the top of the workout view -->
        <div class="flex justify-center space-x-4 pt-4 pb-6 w-full">
            <button id="pause-resume-workout-btn" class="px-6 py-3 bg-blue-600 text-white rounded-lg text-lg font-bold hover:bg-blue-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105">
                <span class="flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><rect width="4" height="16" x="14" y="4" rx="1"/><rect width="4" height="16" x="6" y="4" rx="1"/></svg>
                </span>
            </button>
            <button id="stop-workout-btn" class="px-6 py-3 bg-red-600 text-white rounded-lg text-lg font-bold hover:bg-red-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105">
                <span class="flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><rect width="18" height="18" x="3" y="3" rx="2"/></svg>
                </span>
            </button>
        </div>
        <!-- Main content area (shot display and progress bar) - this will flex-grow and center -->
        <div class="flex-grow flex flex-col items-center justify-center px-4 pb-4">
            <!-- Removed current-pattern-name display as per user request -->
            <p id="current-shot-display" class="text-6xl font-extrabold text-indigo-600 dark:text-indigo-400 mt-2 mb-10"></p>
            <div class="w-full max-w-lg bg-gray-200 rounded-full h-4 dark:bg-gray-700 mb-6">
                <div id="progress-bar" class="bg-green-600 h-4 rounded-full transition-all duration-100 ease-linear" style="width: 0%"></div>
            </div>
        </div>
    </div>

    <!-- Main View Container (holds the accordion list of patterns) -->
    <div id="main-view-container" class="w-full bg-white dark:bg-gray-800 rounded-lg shadow-xl overflow-hidden">

        <!-- Accordion Container - This will be populated dynamically by JavaScript -->
        <div id="patterns-accordion-container" class="divide-y divide-gray-200 dark:divide-gray-700">
            <!-- Pattern accordion items will be dynamically inserted here -->
        </div>

        <div class="flex justify-center space-x-4 p-6 border-t border-gray-200 dark:border-gray-700 mb-4">
            <!-- Delete Pattern Toggle Button -->
            <button id="delete-pattern-toggle-btn" class="px-4 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600" data-state="off">
                <span class="flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M18 6 6 18M6 6l12 12"/></svg>
                </span>
            </button>
            <button id="move-pattern-toggle-btn" class="px-4 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600" data-state="off">
                <span class="flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="m7 15 5 5 5-5M7 9l5-5 5 5"/></svg>
                </span>
            </button>
            <button id="new-pattern-btn" class="px-4 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105">
                <span class="flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-plus-lg" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2"/></svg>
                </span>
            </button>
        </div>

	<hr class="h-px my-8 bg-gray-200 border-0 dark:bg-gray-700">

        <h2 id="workout-config" class="text-lg font-bold text-gray-900 dark:text-white text-center mb-1">Workout Config</h2>

        <!-- Global Workout Order Radios -->
        <div id="global-workout-order-options" class="flex justify-center space-x-4 px-6 py-2">
            <label class="inline-flex items-center">
                <input type="radio" name="globalWorkoutOrder" value="in-order" class="form-radio rounded-full text-indigo-600 focus:ring-indigo-500" checked>
                <span class="ml-2 text-gray-700 dark:text-gray-300">In order</span>
            </label>
            <label class="inline-flex items-center">
                <input type="radio" name="globalWorkoutOrder" value="randomized" class="form-radio rounded-full text-indigo-600 focus:ring-indigo-500">
                <span class="ml-2 text-gray-700 dark:text-gray-300">Randomized</span>
            </label>
        </div>


        <!-- Workout Countdown Slider -->
        <div id="workout-countdown-container" class="px-6 py-4">
            <label for="workout-countdown-slider" class="block mb-2 text-sm font-medium text-gray-900 dark:text-white">Workout Countdown</label>
            <div class="flex items-center space-x-4">
                <input id="workout-countdown-slider" type="range" min="0" max="60" value="0" step="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
                <span id="workout-countdown-display" class="text-sm font-semibold text-indigo-600 dark:text-indigo-400 w-12 text-center">0s</span>
            </div>
        </div>

        <!-- Global Workout Limit Controls -->
        <div id="global-limit-container" class="px-6 py-4">
            <label for="global-limit-type" class="block mb-2 text-sm font-medium text-gray-900 dark:text-white">Workout Limit</label>
            <select id="global-limit-type" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500">
                <option value="all" selected>All pattern shots</option>
                <option value="shot">Shot limit</option>
                <option value="time">Time limit</option>
            </select>
            <!-- Shot Limit Slider (conditionally shown) -->
            <div id="global-shot-limit-controls" class="mt-4 hidden">
                <div class="flex items-center space-x-4">
                    <input id="global-shot-limit-slider" type="range" min="0" max="100" value="0" step="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
                    <span id="global-shot-limit-display" class="text-sm font-semibold text-indigo-600 dark:text-indigo-400 w-20 text-center">0 shots</span>
                </div>
            </div>
            <!-- Time Limit Slider (conditionally shown) -->
            <div id="global-time-limit-controls" class="mt-4 hidden">
                <div class="flex items-center space-x-4">
                    <input id="global-time-limit-slider" type="range" min="60" max="3599" value="60" step="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
                    <span id="global-time-limit-display" class="text-sm font-semibold text-indigo-600 dark:text-indigo-400 w-20 text-center">01:00</span>
                </div>
            </div>
        </div>

        <!-- Hidden template for an accordion item in the main list view -->
        <template id="pattern-list-item-template">
            <div class="accordion-item group bg-white dark:bg-gray-800">
                <!-- Accordion Header -->
                <div class="accordion-header flex items-center justify-between p-4 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 transition duration-150 ease-in-out">
                    <div class="flex items-center space-x-3 flex-grow">
                        <!-- Left Justified Icons (Move/Delete) -->
                        <!-- X icon -->
                        <svg class="h-5 w-5 text-red-500 flex-shrink-0 delete-toggle hidden cursor-pointer" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true">
                            <path d="M18 6 6 18M6 6l12 12"/>
                        </svg>
                        <!-- Up Chevron icon -->
                        <svg class="h-5 w-5 text-gray-500 flex-shrink-0 chevron-up-toggle hidden cursor-pointer" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true">
                            <path d="m18 15-6-6-6 6"/>
                        </svg>
                        <!-- Down Chevron icon -->
                        <svg class="h-5 w-5 text-gray-500 flex-shrink-0 chevron-down-toggle hidden cursor-pointer" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true">
                            <path d="m6 9 6 6 6-6"/>
                        </svg>
                        <span class="pattern-name-display text-lg font-semibold text-gray-800 dark:text-gray-200 flex-grow">Pattern Name</span>
                    </div>
                    <!-- Right Justified Icon (Right Chevron - for visual expand effect, clicking header navigates) -->
                    <svg class="right-chevron h-5 w-5 text-gray-400 flex-shrink-0 transition-transform duration-150 ease-in-out" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m8.25 4.5 7.5 7.5-7.5 7.5"/></svg>
                </div>
                <!-- This body will be minimal/empty as editor is separate -->
                <div class="accordion-body hidden p-4 text-sm text-gray-600 dark:text-gray-400">
                    <!-- Summary info can go here if desired, e.g., Shots: 20, Interval: 6s -->
                    <span class="pattern-summary dark:text-gray-200"></span>
                </div>
            </div>
        </template>
    </div>

    <!-- Pattern Editor Container (separate screen) -->
    <div id="pattern-editor-container" class="w-full bg-white dark:bg-gray-800 hidden">
        <!-- Back to List Button -->
        <div class="mb-4">
            <button id="back-to-list-btn" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-arrow-left" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 0 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8"/></svg>
                <span class="text-sm">Back to List</span>
            </button>
        </div>

        <!-- This div will contain the dynamically generated sequences -->
        <div id="sequences-container" class="overflow-hidden">
            <!-- Sequence Template - Keep it hidden and clone for editing -->
            <template id="sequence-template">
                <div class="w-full max-w-2xl rounded-xl bg-white p-2 shadow-lg dark:bg-gray-800">
                    <div class="space-y-4">
                        <!-- New editable pattern name - Left Justified -->
                        <h3 id="pattern-name-display" class="text-xl font-bold text-indigo-700 dark:text-indigo-300 mb-4 cursor-pointer"></h3>

                        <div id="accordion-color" data-accordion="collapse" data-active-classes="bg-blue-100 dark:bg-gray-800 text-blue-600 dark:text-white">
                            <!-- Options -->
                            <h2 id="accordion-heading-options">
                                <button type="button" class="flex w-full items-center justify-between gap-3 rounded-t-lg border border-b-0 border-gray-200 p-3 font-medium text-gray-500 hover:bg-blue-100 focus:ring-4 focus:ring-blue-200 rtl:text-right dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800 dark:focus:ring-blue-800" data-accordion-target="#accordion-body-options" aria-expanded="false" aria-controls="accordion-body-options">
                                    <span class="flex items-center gap-2">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-list-ul" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M5 11.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m-3 1a1 1 0 1 0 0-2 1 1 0 0 0 0 2m0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2m0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2"/></svg>
                                        <span class="font-bold">Options - </span><span id="optionsCountDisplay" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                                    </span>
                                    <svg data-accordion-icon class="h-3 w-3 shrink-0" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5 5 1 1 5"></path></svg>
                                </button>
                            </h2>
                            <div id="accordion-body-options" class="hidden" aria-labelledby="accordion-heading-options">
                                <div class="border-x border-t border-gray-200 p-3 dark:border-gray-700">
                                    <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">Available shot locations or types</p>
                                    <div>
                                        <textarea id="shotOptions" rows="4" class="block w-full rounded-lg border border-gray-300 bg-gray-50 p-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500"></textarea>
                                    </div>
                                </div>
                            </div>

                            <!-- Narration -->
                            <h2 id="accordion-heading-narration">
                                <button type="button" class="flex w-full items-center justify-between gap-3 border border-b-0 border-gray-200 p-3 font-medium text-gray-500 hover:bg-blue-100 focus:ring-4 focus:ring-blue-200 rtl:text-right dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800 dark:focus:ring-blue-800" data-accordion-target="#accordion-narration-body" aria-expanded="false" aria-controls="accordion-narration-body">
                                    <span class="flex items-center gap-2">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chat-left-text" viewBox="0 0 16 16"><path d="M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2z"/><path d="M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5M3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6m0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5"/></svg>
                                        <span class="font-bold">Narration - </span><span id="narrationDisplay" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                                    </span>
                                    <svg data-accordion-icon class="h-3 w-3 shrink-0" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5 5 1 1 5"></path></svg>
                                </button>
                            </h2>
                            <div id="accordion-narration-body" class="hidden" aria-labelledby="accordion-heading-narration">
                                <div class="border-x border-t border-gray-200 p-3 dark:border-gray-700">
                                    <div class="mb-4"><label class="inline-flex items-center"><input type="checkbox" id="announceShots" class="form-checkbox rounded text-blue-600 focus:ring-blue-500"><span class="ml-2 text-gray-700 dark:text-gray-300">Announce shots</span></label></div>
                                    <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">Optional message before pattern starts</p>
                                    <textarea id="introMessage" rows="2" class="block w-full rounded-lg border border-gray-300 bg-gray-50 p-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500"></textarea>
                                    <p class="mb-2 mt-4 text-sm font-normal text-gray-500 dark:text-gray-400">Optional message after pattern ends</p>
                                    <textarea id="outroMessage" rows="2" class="block w-full rounded-lg border border-gray-300 bg-gray-50 p-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500"></textarea>

                                    <!-- Speech Rate Slider -->
                                    <div class="mt-4">
                                        <label for="speechRate" class="block text-gray-700 text-sm font-bold mb-2 dark:text-gray-300">Speech Rate: <span id="speechRateValue">1.0</span>x</label>
                                        <input type="range" id="speechRate" min="0.5" max="1.5" value="1" step="0.1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
                                    </div>

                                    <!-- Select Voice Dropdown -->
                                    <div class="mt-4 mb-4">
                                        <label for="speechVoiceSelect" class="block text-gray-700 text-sm font-bold mb-2 dark:text-gray-300">Select Voice:</label>
                                        <select id="speechVoiceSelect" class="shadow-sm border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:shadow-outline bg-gray-50 dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                                            <!-- Voices will be populated here by JavaScript -->
                                        </select>
                                    </div>
                                </div>
                            </div>

                            <!-- Sequencing -->
                            <h2 id="accordion-heading-sequencing">
                                <button type="button" class="flex w-full items-center justify-between gap-3 border border-b-0 border-gray-200 p-3 font-medium text-gray-500 hover:bg-blue-100 focus:ring-4 focus:ring-blue-200 rtl:text-right dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800 dark:focus:ring-blue-800" data-accordion-target="#accordion-sequencing-body" aria-expanded="false" aria-controls="accordion-sequencing-body">
                                    <span class="flex items-center gap-2">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-bar-chart-steps" viewBox="0 0 16 16"><path d="M.5 0a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-1 0V.5A.5.5 0 0 1 .5 0M2 1.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-4a.5.5 0 0 1-.5-.5zm2 4a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-7a.5.5 0 0 1-.5-.5zm2 4a.5.5 0 0 1 .5-.5h6a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-6a.5.5 0 0 1-.5-.5zm2 4a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-7a.5.5 0 0 1-.5-.5z"></path></svg>
                                        <span class="font-bold">Sequencing - </span><span id="sequencingOrderDisplay" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                                    </span>
                                    <svg data-accordion-icon class="h-3 w-3 shrink-0" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5 5 1 1 5"></path></svg>
                                </button>
                            </h2>
                            <div id="accordion-sequencing-body" class="hidden" aria-labelledby="accordion-heading-sequencing">
                                <div class="border-x border-t border-gray-200 p-3 dark:border-gray-700">
                                    <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">How to iterate through the pattern options</p>
                                    <div class="mb-4 flex flex-wrap items-center justify-start space-x-4">
                                        <label class="inline-flex items-center"><input type="radio" name="seriesOrder" value="in-order" class="form-radio rounded-full text-blue-600 focus:ring-blue-500"><span class="ml-2 text-gray-700 dark:text-gray-300">In order</span></label>
                                        <label class="inline-flex items-center"><input type="radio" name="seriesOrder" value="randomized" class="form-radio rounded-full text-blue-600 focus:ring-blue-500"><span class="ml-2 text-gray-700 dark:text-gray-300">Randomized</span></label>
                                    </div>
                                </div>
                            </div>

                            <!-- Interval -->
                            <h2 id="accordion-heading-interval">
                                <button type="button" class="flex w-full items-center justify-between gap-3 border border-b-0 border-gray-200 p-3 font-medium text-gray-500 hover:bg-blue-100 focus:ring-4 focus:ring-blue-200 rtl:text-right dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800 dark:focus:ring-blue-800" data-accordion-target="#accordion-interval-body" aria-expanded="false" aria-controls="accordion-interval-body">
                                    <span class="flex items-center gap-2">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-bar-right" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M6 8a.5.5 0 0 0 .5.5h5.793l-2.147 2.146a.5.5 0 0 0 .708.708l3-3a.5.5 0 0 0 0-.708l-3-3a.5.5 0 0 0-.708.708L12.293 7.5H6.5A.5.5 0 0 0 6 8m-2.5 7a.5.5 0 0 1-.5-.5v-13a.5.5 0 0 1 1 0v13a.5.5 0 0 1-.5.5"></path></svg>
                                        <span class="font-bold">Interval - </span><span id="intervalCombinedDisplay" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                                    </span>
                                    <svg data-accordion-icon class="h-3 w-3 shrink-0" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5 5 1 1 5"></path></svg>
                                </button>
                            </h2>
                            <div id="accordion-interval-body" class="hidden" aria-labelledby="accordion-heading-interval">
                                <div class="border-x border-t border-gray-200 p-3 dark:border-gray-700">
                                    <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">Time between each shot</p>
                                    <input type="range" id="shotInterval" min="3.0" max="8.0" step="0.1" class="w-full accent-blue-600">
                                    <p class="mb-2 mt-4 text-sm font-normal text-gray-500 dark:text-gray-400">Shot interval fuzz</p>
                                    <input type="range" id="randomOffset" min="0.0" max="1.0" step="0.1" class="w-full accent-blue-600">
                                    <p class="mb-2 mt-4 text-sm font-normal text-gray-500 dark:text-gray-400">Next shot announcement</p>
                                    <input type="range" id="nextShotAnnouncement" min="0.0" max="7.0" step="0.1" class="w-full accent-blue-600">
                                </div>
                            </div>

                            <!-- Limits -->
                            <h2 id="accordion-heading-limits">
                                <button type="button" class="flex w-full items-center justify-between gap-3 border border-b-0 border-gray-200 p-3 font-medium text-gray-500 hover:bg-blue-100 focus:ring-4 focus:ring-blue-200 rtl:text-right dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800 dark:focus:ring-blue-800" data-accordion-target="#accordion-limits-body" aria-expanded="false" aria-controls="accordion-limits-body">
                                    <span class="flex items-center gap-2">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-123" viewBox="0 0 16 16"><path d="M2.873 11.297V4.142H1.699L0 5.379v1.137l1.64-1.18h.06v5.961zm3.213-5.09v-.063c0-.618.44-1.169 1.196-1.169.676 0 1.174.44 1.174 1.106 0 .624-.42 1.101-.807 1.526L4.99 10.553v.744h4.78v-.99H6.643v-.069L8.41 8.252c.65-.724 1.237-1.332 1.237-2.27C9.646 4.849 8.723 4 7.308 4c-1.573 0-2.36 1.064-2.36 2.15v.057zm6.559 1.883h.786c.823 0 1.374.481 1.379 1.179.01.707-.55 1.216-1.421 1.21-.77-.005-1.326-.419-1.379-.953h-1.095c.042 1.053.938 1.918 2.464 1.918 1.478 0 2.642-.839 2.62-2.144-.02-1.143-.922-1.651-1.551-1.714v-.063c.535-.09 1.347-.66 1.326-1.678-.026-1.053-.933-1.855-2.359-1.845-1.5.005-2.317.88-2.348 1.898h1.116c.032-.498.498-.944 1.206-.944.703 0 1.206.435 1.206 1.07.005.64-.504 1.106-1.2 1.106h-.75z"/></svg>
                                        <span class="font-bold">Limits - </span><span id="limitsDisplay" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                                    </span>
                                    <svg data-accordion-icon class="h-3 w-3 shrink-0" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5 5 1 1 5"></path></svg>
                                </button>
                            </h2>
                            <div id="accordion-limits-body" class="hidden" aria-labelledby="accordion-heading-limits">
                                <div class="border-x border-t border-gray-200 p-3 dark:border-gray-700">
                                    <div class="mb-4">
                                        <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">Pattern bounds</p>
                                        <select id="limitTypeSelect" class="block w-full rounded-lg border border-gray-300 bg-gray-50 p-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500">
                                            <option value="shot">Max Shots</option>
                                            <option value="time">Max Time</option>
                                        </select>
                                    </div>
                                    <input type="range" id="patternLimitSlider" min="0" max="100" class="w-full accent-blue-600 mt-2">
                                </div>
                            </div>

                            <!-- Post Pattern Rest -->
                            <h2 id="accordion-heading-post-rest">
                                <button type="button" class="flex w-full items-center justify-between gap-3 border border-gray-200 p-3 font-medium text-gray-500 hover:bg-blue-100 focus:ring-4 focus:ring-blue-200 rtl:text-right dark:border-gray-700 dark:text-gray-400 dark:hover:bg-gray-800 dark:focus:ring-blue-800" data-accordion-target="#accordion-post-rest-body" aria-expanded="false" aria-controls="accordion-post-rest-body">
                                    <span class="flex items-center gap-2">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-heart-pulse" viewBox="0 0 16 16"><path d="m8 2.748-.717-.737C5.6.281 2.514.878 1.4 3.053.918 3.995.78 5.323 1.508 7H.43c-2.128-5.697 4.165-8.83 7.394-5.857q.09.083.176.171a3 3 0 0 1 .176-.17c3.23-2.974 9.522.159 7.394 5.856h-1.078c.728-1.677.59-3.005.108-3.947C13.486.878 10.4.28 8.717 2.01zM2.212 10h1.315C4.593 11.183 6.05 12.458 8 13.795c1.949-1.337 3.407-2.612 4.473-3.795h1.315c-1.265 1.566-3.14 3.25-5.788 5-2.648-1.75-4.523-3.434-5.788-5"/><path d="M10.464 3.314a.5.5 0 0 0-.945.049L7.921 8.956 6.464 5.314a.5.5 0 0 0-.88-.091L3.732 8H.5a.5.5 0 0 0 0 1H4a.5.5 0 0 0 .416-.223l1.473-2.209 1.647 4.118a.5.5 0 0 0 .945-.049l1.598-5.593 1.457 3.642A.5.5 0 0 0 12 9h3.5a.5.5 0 0 0 0-1h-3.162z"/></svg>
                                        <span class="font-bold">Post Pattern Rest - </span><span id="postSequenceRestDisplay" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                                    </span>
                                    <svg data-accordion-icon class="h-3 w-3 shrink-0" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5 5 1 1 5"></path></svg>
                                </button>
                            </h2>
                            <div id="accordion-post-rest-body" class="hidden rounded-b-lg border border-t-0 border-gray-200 p-3 dark:border-gray-700">
                                <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">Resting period after this pattern</p>
                                <input type="range" id="postSequenceRest" min="0" max="300" class="w-full accent-blue-600">
                            </div>
                        </div>
                    </div>
                </div>
            </template>
        </div>
        <!-- Centered row of icon buttons - For current pattern in editor -->
        <div class="flex justify-center space-x-4 mt-8">
            <button id="clone-btn" class="flex flex-col items-center p-1 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M15 12v6m-3-3h6"/><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>
                <span class="text-xs mt-1">Clone</span>
            </button>
            <button id="import-btn" class="flex flex-col items-center p-1 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2"/></svg>
                <span class="text-xs mt-1">Import</span>
            </button>
            <button id="save-btn" class="flex flex-col items-center p-1 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z"/><path d="M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7M7 3v4a1 1 0 0 0 1 1h7"/></svg>
                <span class="text-xs mt-1">Save</span>
            </button>
            <button id="reset-btn" class="flex flex-col items-center p-1 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                <span class="text-xs mt-1">Reset</span>
            </button>
        </div>
    </div>


    <!-- Global Controls for all patterns -->
    <div id="global-controls" class="flex justify-center space-x-4 mt-8 hidden">
        <button id="load-all-btn" class="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 w-32">Load</button>
        <button id="save-all-btn" class="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 w-32">Save</button>
        <button id="reset-all-btn" class="px-6 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 w-32">Reset</button> <!-- Changed from Reset All to Reset -->
    </div>

    <!-- The Confirmation Modal (for delete/reset) -->
    <div id="confirmation-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 hidden">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm">
            <h3 id="modal-title" class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Confirm Deletion</h3>
            <p id="modal-text" class="text-sm text-gray-600 dark:text-gray-300 mb-6">Are you sure you want to delete this pattern? This action cannot be undone.</p>
            <div class="flex justify-end space-x-4">
                <button id="cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 dark:bg-gray-600 dark:text-gray-200 dark:hover:bg-gray-500">Cancel</button>
                <button id="confirm-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Delete</button>
            </div>
        </div>
    </div>

    <!-- App Footer -->
    <hr class="h-px my-8 bg-gray-200 border-0 dark:bg-gray-700">
    <div id="app-footer-container" class="text-center mt-8">
      <img id="app-footer" src="" alt="Squash Ghoster Footer" class="mx-auto w-full max-w-md h-auto">
    </div>

    <!-- Custom Alert Modal -->
    <div id="alert-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 hidden">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm">
            <h3 id="alert-title" class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Alert</h3>
            <p id="alert-message" class="text-sm text-gray-600 dark:text-gray-300 mb-6"></p>
            <div class="flex justify-end">
                <button id="alert-ok-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">OK</button>
            </div>
        </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // --- STATE MANAGEMENT ---
      let sequences = [];
      let activeSequenceIndex = -1; // -1 means no sequence is actively being edited
      let selectedPatternId = null; // Store the ID of the selected row for focus tracking
      let isMoveModeOn = false; // State for move mode in the accordion list
      let isDeleteModeOn = false; // State for delete mode in the accordion list
      let workoutOrderMode = 'in-order'; // New state for global workout order
      let workoutCountdownTime = 0; // New state for workout countdown
      let globalLimitType = 'all'; // 'all', 'shot', or 'time'
      let globalShotLimit = 0;
      let globalTimeLimit = 60;


      const mainViewContainer = document.getElementById('main-view-container');
      const patternsAccordionContainer = document.getElementById('patterns-accordion-container');
      const patternListItemTemplate = document.getElementById('pattern-list-item-template'); // Template for list items
      const patternEditorContainer = document.getElementById('pattern-editor-container'); // The dedicated editor screen
      const sequencesContainer = document.getElementById('sequences-container'); // Used for the old editor structure
      const sequenceTemplate = document.getElementById('sequence-template'); // Used for the old editor structure

      const appContainer = document.getElementById('app-container');
      const globalControls = document.getElementById('global-controls');
      const movePatternToggleButton = document.getElementById('move-pattern-toggle-btn');
      const deletePatternToggleButton = document.getElementById('delete-pattern-toggle-btn');
      const newPatternBtn = document.getElementById('new-pattern-btn');

      const startWorkoutButton = document.getElementById('start-workout-btn');
      const startWorkoutContainer = document.getElementById('start-workout-container');

      const globalWorkoutOrderOptions = document.getElementById('global-workout-order-options');
      const globalWorkoutOrderRadios = globalWorkoutOrderOptions.querySelectorAll('input[name="globalWorkoutOrder"]');

      // --- Countdown Elements ---
      const workoutCountdownSlider = document.getElementById('workout-countdown-slider');
      const workoutCountdownDisplay = document.getElementById('workout-countdown-display');

      // --- Global Limit Elements ---
      const globalLimitTypeSelect = document.getElementById('global-limit-type');
      const globalShotLimitControls = document.getElementById('global-shot-limit-controls');
      const globalShotLimitSlider = document.getElementById('global-shot-limit-slider');
      const globalShotLimitDisplay = document.getElementById('global-shot-limit-display');
      const globalTimeLimitControls = document.getElementById('global-time-limit-controls');
      const globalTimeLimitSlider = document.getElementById('global-time-limit-slider');
      const globalTimeLimitDisplay = document.getElementById('global-time-limit-display');


      // --- Workout View Elements ---
      const workoutViewContainer = document.getElementById('workout-view-container');
      const stopWorkoutBtn = document.getElementById('stop-workout-btn');
      const pauseResumeWorkoutBtn = document.getElementById('pause-resume-workout-btn');
      const currentShotDisplay = document.getElementById('current-shot-display');
      const progressBar = document.getElementById('progress-bar');
      // Removed currentPatternNameDisplay as per user request
      // const appTitle = document.getElementById('app-title'); // This is now removed

      const appBanner = document.getElementById('app-banner'); // Reference to the image banner
      const appFooter = document.getElementById('app-footer'); // Reference to the footer image banner


      // --- Web Audio API ---
      let audioContext = null;

      // --- Speech Synthesis API ---
      let synth = null;
      let isRoutineRunning = false;
      let nextSilentUtteranceTimeout = null;

      // --- Speech Voice & Rate state (for global usage during workout) ---
      let globalSpeechVoice = null; // Will store the selected SpeechSynthesisVoice object
      let globalSpeechRate = 1.0;

      // --- SVG Icons ---
      const PAUSE_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><rect width="4" height="16" x="14" y="4" rx="1"/><rect width="4" height="16" x="6" y="4" rx="1"/></svg>`;
      const PLAY_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="m6 3 14 9-14 9z"/></svg>`;
      const STOP_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><rect width="18" height="18" x="3" y="3" rx="2"/></svg>`;
      const REPLAY_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>`;
      const EXIT_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M13 3h6a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-6M3 3l9 9M3 9V3h6"/></svg>`;


      // --- UTILITY FUNCTIONS ---
      const formatTime = (totalSeconds) => {
        const roundedSeconds = Math.round(totalSeconds);
        if (roundedSeconds === 0) return 'None';
        const minutes = Math.floor(roundedSeconds / 60);
        const seconds = roundedSeconds % 60;
        const formattedMinutes = minutes < 10 ? `0${minutes}` : `${minutes}`;
        const formattedSeconds = seconds < 10 ? `0${seconds}` : `${seconds}`;
        return `${formattedMinutes}:${formattedSeconds}`;
      };

      const getNewSequenceData = () => {
        const defaultShotOptions = 'Front left\nFront right\nMid left\nMid right\nBack left\nBack right';
        const defaultMaxShots = 20;
        const defaultMaxTimeSeconds = 120; // 2 minutes
        return {
          id: Date.now() + Math.random(),
          patternName: 'New Pattern',
          shotOptions: defaultShotOptions,
          announceShots: true,
          introMessage: '',
          outroMessage: '',
          seriesOrder: 'in-order',
          shotInterval: 6.0,
          randomOffset: 0.0,
          nextShotAnnouncement: 3.0,
          limitType: 'shot',
          patternLimit: defaultMaxShots,
          postSequenceRest: 0,
          previousShotLimit: defaultMaxShots,
          previousTimeLimit: defaultMaxTimeSeconds,
          speechRate: 1.0, // New: Default speech rate
          speechVoice: 'default' // New: Default voice name or 'default'
        };
      };

      const focusOnTop = () => {
        if(appContainer) {
          appContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      };

      const sanitizeFilename = (name) => {
        return name.replace(/[^a-z0-9\s-]/gi, '').replace(/\s+/g, '-');
      };

      const isValidPatternConfig = (data) => {
        const requiredProps = [
          'patternName', 'shotOptions', 'announceShots', 'introMessage', 'outroMessage',
          'seriesOrder', 'shotInterval', 'randomOffset', 'nextShotAnnouncement', 'limitType', 'patternLimit',
          'postSequenceRest', 'speechRate', 'speechVoice' // Added new properties
        ];
        const hasAllProps = requiredProps.every(prop => Object.prototype.hasOwnProperty.call(data, prop));
        if (!hasAllProps) return false;
        if (typeof data.patternName !== 'string' ||
            typeof data.shotOptions !== 'string' ||
            typeof data.announceShots !== 'boolean' ||
            typeof data.introMessage !== 'string' ||
            typeof data.outroMessage !== 'string' ||
            !['in-order', 'randomized'].includes(data.seriesOrder) ||
            typeof data.shotInterval !== 'number' ||
            typeof data.randomOffset !== 'number' ||
            typeof data.nextShotAnnouncement !== 'number' ||
            !['shot', 'time'].includes(data.limitType) ||
            typeof data.patternLimit !== 'number' ||
            typeof data.postSequenceRest !== 'number' ||
            typeof data.speechRate !== 'number' || // Type check for new property
            typeof data.speechVoice !== 'string') { // Type check for new property
            return false;
        }
        return true;
      };

      const isValidWorkoutFile = (data) => {
          if (typeof data !== 'object' || data === null || Array.isArray(data)) {
              return false;
          }
          if (!Object.prototype.hasOwnProperty.call(data, 'patterns') || !Object.prototype.hasOwnProperty.call(data, 'globalSettings')) {
              return false;
          }
          return Array.isArray(data.patterns) && data.patterns.every(isValidPatternConfig);
      };

      // Custom Alert Modal
      const alertModal = document.getElementById('alert-modal');
      const alertTitle = document.getElementById('alert-title');
      const alertMessage = document.getElementById('alert-message');
      const alertOkBtn = document.getElementById('alert-ok-btn');

      const showAlert = (title, message) => {
          alertTitle.textContent = title;
          alertMessage.textContent = message;
          alertModal.classList.remove('hidden');
          alertOkBtn.onclick = () => {
              alertModal.classList.add('hidden');
          };
      };

      // Function to set interaction mode (move, delete, or null for off)
      const setInteractionMode = (mode) => {
          const wasMoveModeOn = isMoveModeOn;
          const wasDeleteModeOn = isDeleteModeOn;

          isMoveModeOn = (mode === 'move');
          isDeleteModeOn = (mode === 'delete');

          // Update toggle button visuals
          movePatternToggleButton.classList.toggle('bg-blue-600', isMoveModeOn);
          movePatternToggleButton.classList.toggle('text-white', isMoveModeOn);
          movePatternToggleButton.classList.toggle('bg-gray-200', !isMoveModeOn);
          movePatternToggleButton.classList.toggle('text-gray-700', !isMoveModeOn);
          movePatternToggleButton.classList.toggle('dark:bg-gray-700', !isMoveModeOn);
          movePatternToggleButton.classList.toggle('dark:text-gray-300', !isMoveModeOn);
          movePatternToggleButton.dataset.state = isMoveModeOn ? 'on' : 'off';

          deletePatternToggleButton.classList.toggle('bg-red-600', isDeleteModeOn);
          deletePatternToggleButton.classList.toggle('text-white', isDeleteModeOn);
          deletePatternToggleButton.classList.toggle('bg-gray-200', !isDeleteModeOn);
          deletePatternToggleButton.classList.toggle('text-gray-700', !isDeleteModeOn);
          deletePatternToggleButton.classList.toggle('dark:bg-gray-700', !isDeleteModeOn);
          deletePatternToggleButton.classList.toggle('dark:text-gray-300', !isDeleteModeOn);
          deletePatternToggleButton.dataset.state = isDeleteModeOn ? 'on' : 'off';

          // Only re-render accordion if a mode state actually changed
          if (wasMoveModeOn !== isMoveModeOn || wasDeleteModeOn !== isDeleteModeOn) {
              renderAccordionView(); // Re-render accordion to show/hide specific buttons/icons
          }
          toggleOtherButtons(); // Apply global disabling (no opacity for list view, only editor/global buttons)
      };

      // Function to disable/enable other buttons and elements based on active mode
      const toggleOtherButtons = () => {
          const disableGlobalActions = isMoveModeOn || isDeleteModeOn;

          const loadAllBtn = document.getElementById('load-all-btn');
          const saveAllBtn = document.getElementById('save-all-btn');
          const resetAllBtn = document.getElementById('reset-all-btn');
          const startWorkoutBtn = document.getElementById('start-workout-btn');

          const elementsToToggleDisable = [
              newPatternBtn, loadAllBtn, saveAllBtn, startWorkoutBtn
          ];

          // Elements in the editor view
          const backToListBtn = document.getElementById('back-to-list-btn');
          const cloneBtn = document.getElementById('clone-btn');
          const importBtn = document.getElementById('import-btn');
          const saveBtn = document.getElementById('save-btn');
          const resetBtn = document.getElementById('reset-btn');


          elementsToToggleDisable.forEach(element => {
              if (element) {
                  element.disabled = disableGlobalActions;
                  // NO OPACITY OR CURSOR-NOT-ALLOWED FOR GLOBAL BUTTONS AS PER NEW REQUIREMENT
              }
          });

          // Specific handling for mode toggle buttons (mutually exclusive)
          if (movePatternToggleButton) {
              movePatternToggleButton.disabled = isDeleteModeOn;
          }
          if (deletePatternToggleButton) {
              deletePatternToggleButton.disabled = isMoveModeOn;
          }

          // Global Reset button is special, it's never disabled by these modes
          if (resetAllBtn) {
            resetAllBtn.disabled = false;
          }

          // Disable/enable elements inside the *editor* view if it's visible
          if (!patternEditorContainer.classList.contains('hidden')) {
              const currentEl = sequencesContainer.firstChild; // Get the currently active cloned sequence element
              if (currentEl) {
                  // Accordion buttons and input fields inside the editor
                  currentEl.querySelectorAll('#accordion-color button[data-accordion-target]').forEach(accordionBtn => {
                      accordionBtn.disabled = disableGlobalActions;
                      accordionBtn.classList.toggle('opacity-50', disableGlobalActions);
                      accordionBtn.classList.toggle('cursor-not-allowed', disableGlobalActions);
                  });

                  currentEl.querySelectorAll('input:not([type="hidden"]), textarea, select').forEach(inputField => {
                      const isInternallyDisabled = (inputField.id === 'nextShotAnnouncement' && !currentEl.querySelector('#announceShots').checked);
                      inputField.disabled = disableGlobalActions || isInternallyDisabled;
                      inputField.classList.toggle('opacity-50', disableGlobalActions || isInternallyDisabled);
                      inputField.classList.toggle('cursor-not-allowed', disableGlobalActions || isInternallyDisabled);
                  });

                  const editorButtonsToToggle = [backToListBtn, cloneBtn, importBtn, saveBtn, resetBtn];
                  editorButtonsToToggle.forEach(element => {
                      if (element) {
                          element.disabled = disableGlobalActions;
                          element.classList.toggle('opacity-50', disableGlobalActions);
                          element.classList.toggle('cursor-not-allowed', disableGlobalActions);
                      }
                  });

                  const patternNameDisplay = currentEl.querySelector('#pattern-name-display');
                  if (patternNameDisplay) {
                    if (disableGlobalActions) {
                        patternNameDisplay.classList.remove('cursor-pointer');
                        patternNameDisplay.style.pointerEvents = 'none';
                    } else {
                        patternNameDisplay.classList.add('cursor-pointer');
                        patternNameDisplay.style.pointerEvents = 'auto';
                    }
                  }
              }
          }
      };


      // --- VIEW MANAGEMENT ---
      const showView = (view) => {
          // Reset appContainer styles before applying view-specific ones
          appContainer.classList.remove(
            'max-w-2xl', 'rounded-xl', 'bg-white', 'p-6', 'shadow-lg', 'dark:bg-gray-800',
            'absolute', 'inset-0', 'flex', 'flex-col', 'items-center', 'justify-center'
          );
          document.body.classList.remove('items-center', 'justify-center', 'p-0');

          // Hide all view containers initially
          mainViewContainer.classList.add('hidden');
          startWorkoutContainer.classList.add('hidden');
          globalControls.classList.add('hidden');
          workoutViewContainer.classList.add('hidden');
          patternEditorContainer.classList.add('hidden'); // Ensure editor is hidden
          // App Banner & Footer visibility handling
          document.getElementById('app-banner-container').classList.remove('hidden'); // Default to visible
          document.getElementById('app-footer-container').classList.remove('hidden'); // Default to visible


          if (view === 'main') {
              appContainer.classList.add('max-w-2xl', 'rounded-xl', 'bg-white', 'p-6', 'shadow-lg', 'dark:bg-gray-800');
              document.body.classList.add('items-center', 'justify-center');
              mainViewContainer.classList.remove('hidden');
              startWorkoutContainer.classList.remove('hidden');
              globalControls.classList.remove('hidden');
              globalWorkoutOrderOptions.classList.remove('hidden'); // Ensure radios are visible
              renderAccordionView(); // Render the list
              updateGlobalLimitControls();
              calculateTotalWorkoutTime();
              focusOnTop();
              setInteractionMode(null); // Ensure modes are off when entering main view
          } else if (view === 'editor') {
              appContainer.classList.add('max-w-2xl', 'rounded-xl', 'bg-white', 'p-6', 'shadow-lg', 'dark:bg-gray-800');
              document.body.classList.add('items-center', 'justify-center');
              patternEditorContainer.classList.remove('hidden');
              globalWorkoutOrderOptions.classList.add('hidden'); // Hide radios in editor
              renderPatternEditor(); // Populate the editor with activePatternId's data
              focusOnTop();
              // No mode selection in editor, so ensure modes are off
              isMoveModeOn = false;
              isDeleteModeOn = false;
              toggleOtherButtons(); // Update button states based on being in editor
          } else if (view === 'workout') {
              appContainer.classList.add('absolute', 'inset-0', 'flex', 'flex-col');
              document.body.classList.add('p-0');
              workoutViewContainer.classList.remove('hidden');
              document.getElementById('app-banner-container').classList.add('hidden'); // Hide app banner on workout screen
              document.getElementById('app-footer-container').classList.add('hidden'); // Hide app footer on workout screen
              globalWorkoutOrderOptions.classList.add('hidden'); // Hide radios in workout view
              focusOnTop();
          }
      };

      // --- ESTIMATED WORKOUT TIME CALCULATION ---
      const calculateTotalWorkoutTime = () => {
          let totalTime = 0;
          if (globalLimitType === 'time') {
              totalTime = globalTimeLimit;
          } else if (globalLimitType === 'shot') {
              // Calculate average shot interval across all patterns to estimate time for global shot limit
              let totalIntervalSum = 0;
              let patternCountWithShots = 0;
              sequences.forEach(pattern => {
                  const shotsInPattern = (pattern.shotOptions || '').trim().split(/[\n,]+/).filter(Boolean).length;
                  if (shotsInPattern > 0) {
                      // Average expected interval for this pattern
                      totalIntervalSum += (parseFloat(pattern.shotInterval) + parseFloat(pattern.randomOffset) / 2);
                      patternCountWithShots++;
                  }
              });

              if (patternCountWithShots > 0) {
                  const averageShotInterval = totalIntervalSum / patternCountWithShots;
                  totalTime = globalShotLimit * averageShotInterval;
              } else {
                  totalTime = 0; // No patterns with shots, so estimated time for shots is 0
              }
          } else { // globalLimitType === 'all'
              sequences.forEach(pattern => {
                  let patternDuration = 0;
                  if (pattern.limitType === 'time') {
                      patternDuration = pattern.patternLimit;
                  } else if (pattern.limitType === 'shot') {
                      // Use average interval for estimation
                      patternDuration = pattern.patternLimit * (parseFloat(pattern.shotInterval) + parseFloat(pattern.randomOffset) / 2);
                  }
                  totalTime += patternDuration;
                  totalTime += pattern.postSequenceRest;
              });
          }
          // Do NOT add workoutCountdownTime to totalTime for display in the "Start" button.
          // totalTime += workoutCountdownTime; // Original line - REMOVED
          startWorkoutButton.textContent = `Start (${formatTime(totalTime)})`;
      };


      // --- ACCORDION LIST VIEW RENDERING ---
      const renderAccordionView = () => {
          patternsAccordionContainer.innerHTML = '';
          if (sequences.length === 0) {
              const noPatternsMessage = document.createElement('div');
              noPatternsMessage.classList.add('p-6', 'text-center', 'text-gray-500', 'dark:text-gray-400');
              noPatternsMessage.textContent = 'No patterns configured. Click the "+" button to add one.';
              patternsAccordionContainer.appendChild(noPatternsMessage);
              updateGlobalLimitControls();
              return;
          }

          sequences.forEach((pattern, index) => {
              const newAccordionItem = patternListItemTemplate.content.cloneNode(true).firstElementChild;
              newAccordionItem.dataset.patternId = pattern.id;
              newAccordionItem.dataset.index = index;

              const patternNameDisplay = newAccordionItem.querySelector('.pattern-name-display');
              const deleteToggle = newAccordionItem.querySelector('.delete-toggle');
              const chevronUpToggle = newAccordionItem.querySelector('.chevron-up-toggle');
              const chevronDownToggle = newAccordionItem.querySelector('.chevron-down-toggle');
              const accordionHeader = newAccordionItem.querySelector('.accordion-header');
              const patternSummarySpan = newAccordionItem.querySelector('.pattern-summary');

              patternNameDisplay.textContent = pattern.patternName;

              // Update summary text (example summary, customize as needed)
              const limitText = pattern.limitType === 'shot' ? `${pattern.patternLimit} shots` : formatTime(pattern.patternLimit);
              patternSummarySpan.textContent = `Shots: ${(pattern.shotOptions || '').trim().split(/[\n,]+/).filter(Boolean).length}, Limit: ${limitText}, Interval: ${pattern.shotInterval}s`;


              // Set visibility of move/delete icons based on mode
              if (isDeleteModeOn) {
                  deleteToggle.classList.remove('hidden');
              } else {
                  deleteToggle.classList.add('hidden');
              }
              if (isMoveModeOn) {
                  chevronUpToggle.classList.remove('hidden');
                  chevronDownToggle.classList.remove('hidden');
              } else {
                  chevronDownToggle.classList.add('hidden');
                  chevronUpToggle.classList.add('hidden');
              }

              // Disable/enable move arrows based on position
              if (index === 0) {
                  chevronUpToggle.classList.add('opacity-30', 'cursor-not-allowed');
              } else {
                  chevronUpToggle.classList.remove('opacity-30', 'cursor-not-allowed');
              }
              if (index === sequences.length - 1) {
                  chevronDownToggle.classList.add('opacity-30', 'cursor-not-allowed');
              } else {
                  chevronDownToggle.classList.remove('opacity-30', 'cursor-not-allowed');
              }

              // Apply 'selected-row' class if this pattern is currently selected in the list
              // Only apply if no mode is active, otherwise selection is implicit by mode.
              if (selectedPatternId === pattern.id && !isMoveModeOn && !isDeleteModeOn) {
                newAccordionItem.classList.add('selected-row');
              } else {
                newAccordionItem.classList.remove('selected-row');
              }


              // Add click listener for header to navigate to editor or trigger mode action
              accordionHeader.addEventListener('click', (e) => {
                  const clickedElement = e.target;
                  if (isMoveModeOn) {
                      if (clickedElement.closest('.chevron-up-toggle')) {
                          movePattern(index, 'up');
                      } else if (clickedElement.closest('.chevron-down-toggle')) {
                          movePattern(index, 'down');
                      }
                      e.stopPropagation(); // Prevent navigation/other clicks
                  } else if (isDeleteModeOn) {
                      if (clickedElement.closest('.delete-toggle')) {
                          showConfirmationModalForDelete(index);
                      }
                      e.stopPropagation(); // Prevent navigation/other clicks
                  } else {
                      // Normal mode: clicking the header (or pattern name) opens the editor
                      // We can also make the right chevron click expand/collapse a summary (optional)
                      if (clickedElement.closest('.pattern-name-display') || clickedElement.closest('.right-chevron')) {
                          activeSequenceIndex = index; // Set the active pattern for the editor
                          showView('editor'); // Navigate to editor view
                          e.stopPropagation(); // Prevent any other clicks from propagating
                      }
                  }
              });

              patternsAccordionContainer.appendChild(newAccordionItem);
          });
          toggleOtherButtons(); // Ensure global buttons react to mode changes
          updateGlobalLimitControls();
      };

      /**
       * Renders the editor view with the data of the currently active pattern.
       */
      const renderPatternEditor = () => {
          sequencesContainer.innerHTML = ''; // Clear any previous content in the sequences container
          if (activeSequenceIndex === -1 || sequences.length === 0) {
              showView('main'); // Go back if no active pattern found
              showAlert('Error', 'Could not load pattern editor.');
              return;
          }

          const currentData = sequences[activeSequenceIndex];
          const newSequenceEl = sequenceTemplate.content.cloneNode(true).firstElementChild; // Clone the template content
          newSequenceEl.id = `sequence-${currentData.id}`; // Give the cloned element a unique ID
          // Removed: newSequenceEl.classList.remove('hidden'); // The template itself is hidden, but the cloned element might not be if it was within the hidden template already.

          sequencesContainer.appendChild(newSequenceEl); // Add the cloned element to the container

          // Get references to elements *within* the newly cloned sequence element
          const patternNameDisplay = newSequenceEl.querySelector('#pattern-name-display');
          const shotOptions = newSequenceEl.querySelector('#shotOptions');
          const announceShots = newSequenceEl.querySelector('#announceShots');
          const introMessage = newSequenceEl.querySelector('#introMessage');
          const outroMessage = newSequenceEl.querySelector('#outroMessage');
          const seriesOrderRadios = newSequenceEl.querySelectorAll('input[name="seriesOrder"]');
          const shotInterval = newSequenceEl.querySelector('#shotInterval');
          const randomOffset = newSequenceEl.querySelector('#randomOffset');
          const nextShotAnnouncement = newSequenceEl.querySelector('#nextShotAnnouncement');
          const limitTypeSelect = newSequenceEl.querySelector('#limitTypeSelect');
          const patternLimitSlider = newSequenceEl.querySelector('#patternLimitSlider');
          const postSequenceRest = newSequenceEl.querySelector('#postSequenceRest');

          // New: Speech Rate and Voice elements
          const speechRateSlider = newSequenceEl.querySelector('#speechRate');
          const speechRateValueDisplay = newSequenceEl.querySelector('#speechRateValue');
          const speechVoiceSelect = newSequenceEl.querySelector('#speechVoiceSelect');


          // Set values to editor fields from currentData
          patternNameDisplay.textContent = currentData.patternName;
          shotOptions.value = currentData.shotOptions;
          announceShots.checked = currentData.announceShots;
          introMessage.value = currentData.introMessage;
          outroMessage.value = currentData.outroMessage;
          seriesOrderRadios.forEach(radio => radio.checked = (radio.value === currentData.seriesOrder));
          shotInterval.value = currentData.shotInterval;
          randomOffset.value = currentData.randomOffset;
          nextShotAnnouncement.value = currentData.nextShotAnnouncement;
          limitTypeSelect.value = currentData.limitType;
          patternLimitSlider.value = currentData.patternLimit;
          postSequenceRest.value = currentData.postSequenceRest;

          // New: Set speech rate and voice
          speechRateSlider.value = currentData.speechRate;
          speechRateValueDisplay.textContent = currentData.speechRate.toFixed(1);
          populateVoiceList(speechVoiceSelect, currentData.speechVoice); // Pass the specific select element and current voice


          // Apply specific logic for sliders/displays
          handleAnnounceShotsChange(newSequenceEl); // Update nextShotAnnouncement max/disabled state
          handleLimitTypeChange(newSequenceEl); // Update patternLimitSlider min/max/value based on type
          updateAllDisplays(newSequenceEl); // Update all summary texts

          initFlowbite(); // Initialize Flowbite for the new accordion elements
          patternNameDisplay.addEventListener('click', () => editPatternName(currentData, patternNameDisplay));
          toggleOtherButtons(); // Update button states based on being in editor
      };


      /**
       * Saves the current state of the editor's input fields back to the `sequences` array.
       */
      const saveCurrentSequenceState = () => {
          // Only proceed if a pattern is selected and the editor is currently visible
          if (activeSequenceIndex === -1 || sequences.length === 0 || patternEditorContainer.classList.contains('hidden')) {
              console.log('saveCurrentSequenceState: Conditions not met (editor hidden or no active pattern), skipping save.');
              return;
          }

          const currentData = sequences[activeSequenceIndex];
          const currentEl = sequencesContainer.firstChild; // This should be the cloned template element
          if (!currentEl) {
              console.log('saveCurrentSequenceState: currentEl is null, skipping save.');
              return;
          }

          // Get references to elements, adding null checks
          const patternNameDisplay = currentEl.querySelector('#pattern-name-display');
          const shotOptions = currentEl.querySelector('#shotOptions');
          const announceShots = currentEl.querySelector('#announceShots');
          const introMessage = currentEl.querySelector('#introMessage');
          const outroMessage = currentEl.querySelector('#outroMessage');
          const seriesOrderCheckedRadio = currentEl.querySelector('input[name="seriesOrder"]:checked'); // This can be null if none checked
          const shotInterval = currentEl.querySelector('#shotInterval');
          const randomOffset = currentEl.querySelector('#randomOffset');
          const nextShotAnnouncement = currentEl.querySelector('#nextShotAnnouncement');
          const limitTypeSelect = currentEl.querySelector('#limitTypeSelect');
          const patternLimitSlider = currentEl.querySelector('#patternLimitSlider');
          const postSequenceRest = currentEl.querySelector('#postSequenceRest');

          // New: Speech Rate and Voice elements
          const speechRateSlider = currentEl.querySelector('#speechRate');
          const speechVoiceSelect = currentEl.querySelector('#speechVoiceSelect');


          // Before attempting to access properties, ensure the element exists.
          // If any critical element is null, we should probably log an error and exit.
          if (!patternNameDisplay || !shotOptions || !announceShots || !introMessage || !outroMessage ||
              !seriesOrderCheckedRadio || !shotInterval || !randomOffset || !nextShotAnnouncement ||
              !limitTypeSelect || !patternLimitSlider || !postSequenceRest ||
              !speechRateSlider || !speechVoiceSelect) { // Added new elements to check
              console.error('saveCurrentSequenceState: One or more required editor elements are null. Skipping save.');
              return;
          }

          // Save the current patternLimit to the appropriate 'previous' field before updating currentData
          if (currentData.limitType === 'shot') {
              currentData.previousShotLimit = parseInt(patternLimitSlider.value);
          } else if (currentData.limitType === 'time') {
              currentData.previousTimeLimit = parseInt(patternLimitSlider.value);
          }

          // Update pattern data from the editor input fields
          currentData.patternName = patternNameDisplay.textContent;
          currentData.shotOptions = shotOptions.value;
          currentData.announceShots = announceShots.checked;
          currentData.introMessage = introMessage.value;
          currentData.outroMessage = outroMessage.value;
          currentData.seriesOrder = seriesOrderCheckedRadio.value;
          currentData.shotInterval = parseFloat(shotInterval.value);
          currentData.randomOffset = parseFloat(randomOffset.value);
          currentData.nextShotAnnouncement = parseFloat(nextShotAnnouncement.value);
          currentData.limitType = limitTypeSelect.value;
          currentData.patternLimit = parseInt(patternLimitSlider.value);
          currentData.postSequenceRest = parseInt(postSequenceRest.value);
          currentData.speechRate = parseFloat(speechRateSlider.value); // Save speech rate
          currentData.speechVoice = speechVoiceSelect.value; // Save selected voice name

          calculateTotalWorkoutTime();
          updateGlobalLimitControls();
      };

      // --- UI UPDATE FUNCTIONS (for the separate editor screen) ---
      const updateAllDisplays = (context) => {
          updateShotOptionsDisplay(context);
          updateNarrationDisplay(context);
          updateSequencingDisplay(context);
          updateIntervalDisplay(context);
          updateLimitsDisplay(context);
          updatePostRestDisplay(context);
      }

      const updateShotOptionsDisplay = (context) => {
        const shotOptions = context.querySelector('#shotOptions');
        const display = context.querySelector('#optionsCountDisplay');
        if (shotOptions && display) { // Add null checks
            const count = (shotOptions.value || '').trim().split(/[\n,]+/).filter(Boolean).length;
            display.textContent = `${count} shots`;
        }
      };

      const updateNarrationDisplay = (context) => {
        const display = context.querySelector('#narrationDisplay');
        const announceShotsCheckbox = context.querySelector('#announceShots');
        const introMessageTextarea = context.querySelector('#introMessage');
        const outroMessageTextarea = context.querySelector('#outroMessage');

        if (display && announceShotsCheckbox && introMessageTextarea && outroMessageTextarea) { // Add null checks
            const parts = [];
            if (announceShotsCheckbox.checked) parts.push('Shots');
            if (introMessageTextarea.value.trim()) parts.push('Intro');
            if (outroMessageTextarea.value.trim()) parts.push('Outro');
            display.textContent = parts.length ? parts.join(', ') : 'None';
        }
      };

      const updateSequencingDisplay = (context) => {
          const display = context.querySelector('#sequencingOrderDisplay');
          const seriesOrderRadio = context.querySelector('input[name="seriesOrder"]:checked');
          if (display && seriesOrderRadio) { // Add null checks
              const value = seriesOrderRadio.value;
              display.textContent = value === 'in-order' ? 'In order' : 'Randomized';
          }
      };

      const updateIntervalDisplay = (context) => {
        const display = context.querySelector('#intervalCombinedDisplay');
        const shotIntervalInput = context.querySelector('#shotInterval');
        const randomOffsetInput = context.querySelector('#randomOffset');
        const nextShotAnnouncementInput = context.querySelector('#nextShotAnnouncement');
        const announceShotsCheckbox = context.querySelector('#announceShots');

        if (display && shotIntervalInput && randomOffsetInput && nextShotAnnouncementInput && announceShotsCheckbox) { // Add null checks
            const interval = parseFloat(shotIntervalInput.value).toFixed(1);
            const offset = parseFloat(randomOffsetInput.value).toFixed(1);
            const nextShotAnnounce = parseFloat(nextShotAnnouncementInput.value).toFixed(1);

            let text = offset > 0 ? `${interval} sec  ${offset}` : `${interval} sec`;
            if (announceShotsCheckbox.checked) {
                text += ` (${nextShotAnnounce}s)`;
            }
            display.textContent = text;
        }
      };

      const handleAnnounceShotsChange = (context) => {
          const announceShotsCheckbox = context.querySelector('#announceShots');
          const nextShotAnnouncementSlider = context.querySelector('#nextShotAnnouncement');
          const shotIntervalSlider = context.querySelector('#shotInterval');

          if (!announceShotsCheckbox || !nextShotAnnouncementSlider || !shotIntervalSlider) return; // Add null checks

          nextShotAnnouncementSlider.disabled = !announceShotsCheckbox.checked;

          if (announceShotsCheckbox.checked) {
              const currentShotInterval = parseFloat(shotIntervalSlider.value);
              nextShotAnnouncementSlider.max = Math.max(0.0, currentShotInterval - 0.1);
              if (parseFloat(nextShotAnnouncementSlider.value) > nextShotAnnouncementSlider.max) {
                  nextShotAnnouncementSlider.value = nextShotAnnouncementSlider.max;
              }
              if (parseFloat(nextShotAnnouncementSlider.value) === 0 && nextShotAnnouncementSlider.max >= 1.25) {
                nextShotAnnouncementSlider.value = 1.25;
              }
          } else {
              nextShotAnnouncementSlider.value = 0;
          }
          updateIntervalDisplay(context);
          updateNarrationDisplay(context);
      };


      const handleLimitTypeChange = (context) => {
        const select = context.querySelector('#limitTypeSelect');
        const slider = context.querySelector('#patternLimitSlider');

        const currentPattern = sequences[activeSequenceIndex];
        if (!currentPattern || !select || !slider) return; // Add null checks

        const newLimitType = select.value;
        const prevLimitTypeInState = currentPattern.limitType;

        // Save the current patternLimit to the appropriate 'previous' field before updating currentData
        if (prevLimitTypeInState === 'shot') {
            currentPattern.previousShotLimit = parseInt(slider.value);
        } else if (prevLimitTypeInState === 'time') {
            currentPattern.previousTimeLimit = parseInt(slider.value);
        }

        currentPattern.limitType = newLimitType;

        let proposedValue;
        if (newLimitType === 'shot') {
            slider.min = 0;
            slider.max = 100;
            proposedValue = (typeof currentPattern.previousShotLimit === 'number' && currentPattern.previousShotLimit > 0)
                                ? currentPattern.previousShotLimit
                                : ((currentPattern.shotOptions || '').trim().split(/[\n,]+/).filter(Boolean).length); // Defensive check for shotOptions
        } else if (newLimitType === 'time') {
            const shotOptionsCount = ((currentPattern.shotOptions || '').trim().split(/[\n,]+/).filter(Boolean).length); // Defensive check
            const estimatedTimeForOptions = shotOptionsCount * currentPattern.shotInterval;

            slider.min = Math.max(1, Math.round(currentPattern.shotInterval));
            slider.max = 1800; // 30 minutes in seconds

            proposedValue = (typeof currentPattern.previousTimeLimit === 'number' && currentPattern.previousTimeLimit > 0)
                                ? currentPattern.previousTimeLimit
                                : Math.round(estimatedTimeForOptions);
        }

        slider.value = Math.min(Math.max(proposedValue, parseInt(slider.min)), parseInt(slider.max));
        currentPattern.patternLimit = parseInt(slider.value);

        updateLimitsDisplay(context);
        calculateTotalWorkoutTime();
      };

      const updateLimitsDisplay = (context) => {
        const display = context.querySelector('#limitsDisplay');
        const typeSelect = context.querySelector('#limitTypeSelect');
        const patternLimitSlider = context.querySelector('#patternLimitSlider');
        if (display && typeSelect && patternLimitSlider) { // Add null checks
            const type = typeSelect.value;
            const value = parseInt(patternLimitSlider.value);
            if (type === 'shot') {
              display.textContent = `${value} shots`;
            } else if (type === 'time') {
              display.textContent = formatTime(value);
            }
        }
      };

      const updatePostRestDisplay = (context) => {
        const display = context.querySelector('#postSequenceRestDisplay');
        const postSequenceRestInput = context.querySelector('#postSequenceRest');
        if (display && postSequenceRestInput) { // Add null checks
            const value = parseInt(postSequenceRestInput.value);
            display.textContent = formatTime(value);
        }
      };

      // --- Speech Synthesis specific functions (reused from previous text-to-speech app) ---
      const currentLang = document.documentElement.lang || navigator.language || 'en-US';
      const langCode = currentLang.split('-')[0]; // Get the primary language code (e.g., 'en' from 'en-US')

      // Function to detect if the user is on an Apple device
      function isAppleOS() {
          const userAgent = navigator.userAgent;

          // 1. Detect macOS:
          // Look for "MacIntel" in navigator.platform or "Macintosh" in userAgent
          const isMacOS = navigator.platform.includes('Mac') || userAgent.includes('Macintosh');

          // 2. Detect iOS/iPadOS (including newer iPadOS that presents as Mac):
          // Use the logic from the previous answer for iOS/iPadOS detection.
          const isIOS = /iPad|iPhone|iPod/.test(userAgent) ||
                        (navigator.platform === 'MacIntel' && typeof navigator.maxTouchPoints === 'number' && navigator.maxTouchPoints > 1);

          return isMacOS || isIOS;
      }

      // Function to populate voice options in the dropdown
      // Takes the select element and the initially selected voice name as arguments
      function populateVoiceList(selectElement, selectedVoiceName) {
            if (!synth) {
                console.warn("Speech synthesis not initialized, cannot populate voice list.");
                return;
            }
            const voices = synth.getVoices();
            selectElement.innerHTML = ''; // Clear existing options

            // Add a default option
            const defaultOption = document.createElement('option');
            defaultOption.textContent = 'Default System Voice';
            defaultOption.value = 'default';
            selectElement.appendChild(defaultOption);

            let filteredVoices = [];

            // Apply specific filtering for English on iOS
            if (isAppleOS() && langCode === 'en') {
                const iOSVoices = ['Karen', 'Daniel', 'Moira', 'Rishi', 'Samantha'];
                filteredVoices = voices.filter(voice => iOSVoices.includes(voice.name));
            } else {
                // Filter voices by the current document's language for other cases
                filteredVoices = voices.filter(voice => voice.lang.startsWith(langCode));
            }

            // Use a Map to store unique voices based on their name to prevent duplicates
            const uniqueVoicesMap = new Map();
            filteredVoices.forEach(voice => {
                if (!uniqueVoicesMap.has(voice.name)) {
                    uniqueVoicesMap.set(voice.name, voice);
                }
            });

            const uniqueFilteredVoices = Array.from(uniqueVoicesMap.values());

            uniqueFilteredVoices.forEach(voice => {
                const option = document.createElement('option');
                option.textContent = `${voice.name} (${voice.lang})`;
                option.value = voice.name;
                selectElement.appendChild(option);
            });

            // Set the selected voice
            if (selectedVoiceName && uniqueFilteredVoices.some(v => v.name === selectedVoiceName)) {
                selectElement.value = selectedVoiceName;
            } else {
                selectElement.value = 'default';
            }
      }


      // --- SEQUENCE MANAGEMENT FUNCTIONS ---
      const addSequence = () => {
        if (!patternEditorContainer.classList.contains('hidden')) { // If in editor, save current
            saveCurrentSequenceState();
        }

        const newSequence = getNewSequenceData();
        newSequence.patternName = `Pattern ${sequences.length + 1}`;
        sequences.push(newSequence);

        activeSequenceIndex = sequences.length - 1; // Make the new pattern the active one
        selectedPatternId = newSequence.id; // Select the new pattern in the list
        showView('editor'); // Go to editor view
        calculateTotalWorkoutTime();
        focusOnTop();
      };

      const cloneSequence = () => {
        if (activeSequenceIndex === -1) {
            showAlert('Clone Error', 'No pattern selected to clone.');
            return;
        }
        saveCurrentSequenceState();

        const clonedData = JSON.parse(JSON.stringify(sequences[activeSequenceIndex]));
        clonedData.id = Date.now() + Math.random();
        clonedData.patternName = `${clonedData.patternName} (Clone)`;

        sequences.splice(activeSequenceIndex + 1, 0, clonedData);
        activeSequenceIndex++; // Move active index to the newly cloned pattern
        selectedPatternId = clonedData.id; // Select the new clone in the list

        renderPatternEditor(); // Re-render editor with cloned data
        calculateTotalWorkoutTime();
        focusOnTop();
      };

      const movePattern = (index, direction) => {
          const patternIdToSelect = sequences[index].id;

          if (direction === 'up' && index > 0) {
              [sequences[index], sequences[index - 1]] = [sequences[index - 1], sequences[index]];
              if (activeSequenceIndex === index) activeSequenceIndex--;
              else if (activeSequenceIndex === index - 1) activeSequenceIndex++;
          } else if (direction === 'down' && index < sequences.length - 1) {
              [sequences[index], sequences[index + 1]] = [sequences[index + 1], sequences[index]];
              if (activeSequenceIndex === index) activeSequenceIndex++;
              else if (activeSequenceIndex === index + 1) activeSequenceIndex--;
          }
          selectedPatternId = patternIdToSelect;
          renderAccordionView(); // Re-render the list to show new order
          calculateTotalWorkoutTime();
      };

      const deleteSequence = (indexToDelete) => {
          // If only one pattern, clear and reset instead of deleting entirely
          if (sequences.length <= 1) {
              const currentPatternId = sequences.length > 0 ? sequences[0].id : null;
              sequences = [];
              sequences.push(getNewSequenceData());
              sequences[0].patternName = "Pattern 1";
              if (currentPatternId) sequences[0].id = currentPatternId; // Retain original ID if it existed
              activeSequenceIndex = 0; // The single pattern becomes active at index 0
              selectedPatternId = sequences[0].id;
              showAlert('Pattern Reset', 'Last pattern reset to default settings.');
              if (patternEditorContainer.classList.contains('hidden')) {
                  showView('main'); // Ensure main view is rendered to show the single pattern
              } else {
                  renderPatternEditor(); // Re-render editor with reset pattern
              }
              calculateTotalWorkoutTime();
              return;
          }

          sequences.splice(indexToDelete, 1);

          // Adjust activeSequenceIndex based on the deletion
          if (activeSequenceIndex === indexToDelete) {
              activeSequenceIndex = Math.max(0, indexToDelete - 1);
              if (sequences.length === 0) activeSequenceIndex = -1;
          } else if (activeSequenceIndex > indexToDelete) {
              activeSequenceIndex--;
          }

          selectedPatternId = activeSequenceIndex !== -1 ? sequences[activeSequenceIndex].id : null;

          if (sequences.length === 0 || activeSequenceIndex === -1) {
              showView('main');
          } else if (!patternEditorContainer.classList.contains('hidden') && sequences[activeSequenceIndex]) {
              renderPatternEditor(); // Re-render the new active sequence in editor if still in editor view
          } else {
            showView('main'); // Go back to main accordion view
          }
          calculateTotalWorkoutTime();
          focusOnTop();
      };


      const resetCurrentSequence = () => {
          if (activeSequenceIndex === -1 || sequences.length === 0) {
            showAlert('Reset Error', 'No pattern selected to reset.');
            return;
          }
          const currentId = sequences[activeSequenceIndex].id;
          sequences[activeSequenceIndex] = { ...getNewSequenceData(), id: currentId };
          sequences[activeSequenceIndex].patternName = `Pattern ${activeSequenceIndex + 1}`;
          selectedPatternId = sequences[activeSequenceIndex].id;
          renderPatternEditor(); // Re-populate editor with reset data
          calculateTotalWorkoutTime();
      };

      // Function to handle pattern name editing in the editor screen
      const editPatternName = (currentData, displayElement) => {
          setInteractionMode(null); // Ensure modes are off

          const inputElement = document.createElement('input');
          inputElement.type = 'text';
          inputElement.value = currentData.patternName;
          inputElement.className = 'text-xl font-bold text-indigo-700 dark:text-indigo-300 w-full bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md p-1';

          displayElement.parentNode.replaceChild(inputElement, displayElement);
          inputElement.focus();

          const saveAndRevert = () => {
              let newName = inputElement.value.trim();
              if (newName === '') {
                  newName = 'Unnamed Pattern';
              }
              currentData.patternName = newName;
              renderPatternEditor(); // Re-render to show updated label
              calculateTotalWorkoutTime();
          };

          inputElement.addEventListener('blur', saveAndRevert);
          inputElement.addEventListener('keydown', (e) => {
              if (e.key === 'Enter') {
                  saveAndRevert();
                  inputElement.blur();
              }
          });
      };

      // --- INDIVIDUAL PATTERN IMPORT / SAVE FUNCTIONS (for the separate editor) ---
      const savePatternConfig = () => {
        const patternToSave = sequences[activeSequenceIndex];
        if (!patternToSave) {
          showAlert('Save Error', 'No pattern selected to save.');
          return;
        }
        saveCurrentSequenceState(); // Ensure data is synced from editor fields
        const dataStr = JSON.stringify(patternToSave, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `${sanitizeFilename(patternToSave.patternName)}.pattern.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showAlert('Pattern Saved', `Pattern "${patternToSave.patternName}" saved successfully.`);
        calculateTotalWorkoutTime();
      };

      const importPatternConfig = () => {
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json,.pattern.json';
        fileInput.style.display = 'none';

        fileInput.addEventListener('change', (event) => {
          const file = event.target.files[0];
          if (!file) {
              document.body.removeChild(fileInput);
              return;
          }

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const importedData = JSON.parse(e.target.result);
              // Provide default values for new speech properties if not present in old files
              if (typeof importedData.speechRate === 'undefined') importedData.speechRate = 1.0;
              if (typeof importedData.speechVoice === 'undefined') importedData.speechVoice = 'default';

              if (isValidPatternConfig(importedData)) {
                if (activeSequenceIndex !== -1) {
                    sequences[activeSequenceIndex] = { ...importedData, id: sequences[activeSequenceIndex].id };
                    renderPatternEditor(); // Re-populate editor with imported data
                    showAlert('Pattern Imported', `Pattern "${importedData.patternName}" imported successfully.`);
                } else {
                    showAlert('Import Error', 'No active pattern to import into.');
                }
                calculateTotalWorkoutTime();
              } else {
                showAlert('Import Error', 'Invalid pattern configuration file. Please select a valid .pattern.json file.');
              }
            } catch (error) {
              showAlert('Import Error', 'Failed to parse file. Please ensure it is a valid JSON file.');
            } finally {
              document.body.removeChild(fileInput);
            }
          };
          reader.onerror = () => {
            showAlert('Import Error', 'Failed to read file.');
            document.body.removeChild(fileInput);
          };
          reader.readAsText(file);
        });

        document.body.appendChild(fileInput);
        fileInput.click();
      };


      // --- GLOBAL WORKOUT (ALL PATTERNS) FUNCTIONS ---
      const loadWorkout = () => {
        setInteractionMode(null); // Turn off any list modes

        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json,.workout.json';
        fileInput.style.display = 'none';

        fileInput.addEventListener('change', (event) => {
          const file = event.target.files[0];
          if (!file) {
              document.body.removeChild(fileInput);
              return;
          }

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
                const importedData = JSON.parse(e.target.result);
                if (!isValidWorkoutFile(importedData)) {
                    showAlert('Load Error', 'Invalid workout file format. Please select a valid workout file.');
                    return;
                }

                sequences = importedData.patterns.map(pattern => {
                    // Provide default values for new speech properties if not present in old files
                    if (typeof pattern.speechRate === 'undefined') pattern.speechRate = 1.0;
                    if (typeof pattern.speechVoice === 'undefined') pattern.speechVoice = 'default';
                    return { ...pattern, id: Date.now() + Math.random() };
                });

                const settings = importedData.globalSettings;
                workoutOrderMode = settings.workoutOrderMode || 'in-order';
                workoutCountdownTime = settings.workoutCountdownTime || 0;
                globalLimitType = settings.globalLimitType || 'all';
                globalShotLimit = settings.globalShotLimit || 0;
                globalTimeLimit = settings.globalTimeLimit || 60;

                // Update UI from loaded global settings
                globalWorkoutOrderRadios.forEach(radio => radio.checked = (radio.value === workoutOrderMode));
                workoutCountdownSlider.value = workoutCountdownTime;
                workoutCountdownDisplay.textContent = `${workoutCountdownTime}s`;
                globalLimitTypeSelect.value = globalLimitType;
                globalShotLimitSlider.value = globalShotLimit;
                globalTimeLimitSlider.value = globalTimeLimit;

                activeSequenceIndex = -1; // Go back to main view
                selectedPatternId = null; // Clear selection
                showView('main'); // This will call renderAccordionView, updateGlobalLimitControls, and calculateTotalWorkoutTime
                showAlert('Workout Loaded', `Successfully loaded ${sequences.length} patterns.`);

            } catch (error) {
              showAlert('Load Error', 'Failed to parse workout file. Please ensure it is a valid JSON file.');
            } finally {
              document.body.removeChild(fileInput);
            }
          };
          reader.onerror = () => {
            showAlert('Load Error', 'Failed to read workout file.');
            document.body.removeChild(fileInput);
          };
          reader.readAsText(file);
        });

        document.body.appendChild(fileInput);
        fileInput.click();
      };

      const saveWorkout = () => {
        setInteractionMode(null); // Turn off any list modes
        if (!patternEditorContainer.classList.contains('hidden')) { // If in editor, save current
          saveCurrentSequenceState();
        }

        if (sequences.length === 0) {
            showAlert('Save Error', 'No patterns to save in the workout file.');
            return;
        }

        const workoutData = {
          patterns: sequences,
          globalSettings: {
            workoutOrderMode: workoutOrderMode,
            workoutCountdownTime: workoutCountdownTime,
            globalLimitType: globalLimitType,
            globalShotLimit: globalShotLimit,
            globalTimeLimit: globalTimeLimit
          }
        };

        const dataStr = JSON.stringify(workoutData, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `my-workout-${new Date().toISOString().slice(0,10)}.workout.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showAlert('Workout Saved', 'Successfully saved workout.');
        calculateTotalWorkoutTime();
      };

      const clearAllPatterns = () => {
          setInteractionMode(null); // Turn off any list modes

          const modal = document.getElementById('confirmation-modal');
          const modalTitle = document.getElementById('modal-title');
          const modalText = document.getElementById('modal-text');
          const confirmBtn = document.getElementById('confirm-btn');
          const cancelBtn = document.getElementById('cancel-btn');

          modalTitle.textContent = 'Confirm Reset';
          modalText.textContent = 'Are you sure you want to clear all workout patterns? This action cannot be undone.';
          confirmBtn.textContent = 'Reset';
          confirmBtn.className = 'px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700';
          modal.classList.remove('hidden');

          confirmBtn.replaceWith(confirmBtn.cloneNode(true));
          cancelBtn.replaceWith(cancelBtn.cloneNode(true));
          const newConfirmBtn = document.getElementById('confirm-btn');
          const newCancelBtn = document.getElementById('cancel-btn');

          newConfirmBtn.addEventListener('click', () => {
              sequences = [];
              sequences.push(getNewSequenceData());
              sequences[0].patternName = "Pattern 1";
              activeSequenceIndex = -1; // Reset to main view
              selectedPatternId = null; // Clear selection
              showView('main');
              modal.classList.add('hidden');
              calculateTotalWorkoutTime();
          }, { once: true });

          newCancelBtn.addEventListener('click', () => {
              modal.classList.add('hidden');
          }, { once: true });
      };

      const showConfirmationModalForDelete = (indexToDelete) => {
          const modal = document.getElementById('confirmation-modal');
          const modalTitle = document.getElementById('modal-title');
          const modalText = document.getElementById('modal-text');
          const confirmBtn = document.getElementById('confirm-btn');
          const cancelBtn = document.getElementById('cancel-btn');

          modalTitle.textContent = 'Confirm Deletion';
          modalText.textContent = `Are you sure you want to delete pattern "${sequences[indexToDelete].patternName}"? This action cannot be undone.`;
          confirmBtn.textContent = 'Delete';
          confirmBtn.className = 'px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700';
          modal.classList.remove('hidden');

          confirmBtn.replaceWith(confirmBtn.cloneNode(true));
          cancelBtn.replaceWith(cancelBtn.cloneNode(true));
          const newConfirmBtn = document.getElementById('confirm-btn');
          const newCancelBtn = document.getElementById('cancel-btn');

          newConfirmBtn.addEventListener('click', () => {
              deleteSequence(indexToDelete);
              modal.classList.add('hidden');
              focusOnTop();
          }, { once: true });

          newCancelBtn.addEventListener('click', () => {
              modal.classList.add('hidden');
          }, { once: true });
      };


    // --- Workout Logic ---
    let countdownTimer = null;
    let currentPatternIndex = 0;
    let currentPatternTimer = null;
    let shotIntervalTimer = null;
    let flashTimer = null;
    let nextAnnouncementTimeout = null;
    let currentPatternShotCount = 0;
    let totalWorkoutShots = 0;
    let currentPatternTimeElapsed = 0;
    let globalWorkoutTimeElapsed = 0;
    let currentShotOptions = [];
    let currentShotIndex = 0;

    let isPaused = false;
    let pausedTimePassed = 0;
    let pausedEffectiveInterval = 0;
    let pausedRestTimeRemaining = 0;
    let pausedShotDisplayContent = '';
    let pausedCountdownTimeRemaining = 0;

    let isToggleDebouncing = false;
    const DEBOUNCE_TIME = 300;

    // New variable to hold the patterns for the current workout run
    let currentWorkoutPatterns = [];

    function initAudioContext() {
        if (audioContext) return; // Already initialized
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // For iIOS 17+: work around ringer mode: https://bugs.webkit.org/show_bug.cgi?id=237322 ***
            if (window.navigator.audioSession && window.navigator.audioSession.type !== "playback") {
                try {
                    window.navigator.audioSession.type = "playback";
                    console.log("navigator.audioSession.type set to 'playback'");
                } catch (e) {
                    console.warn("Failed to set navigator.audioSession.type:", e);
                }
            }

            // If the context is in a suspended state, it requires a user gesture to resume.
            // We'll attach a one-time event listener to resume it on the first user interaction.
            if (audioContext.state === 'suspended') {
                const resumeAudio = () => {
                    audioContext.resume().then(() => {
                        console.log('AudioContext resumed successfully by user gesture.');
                        // Clean up the event listeners once resumed
                        document.removeEventListener('click', resumeAudio);
                        document.removeEventListener('touchend', resumeAudio);
                    }).catch(error => console.error("Error resuming AudioContext:", error));
                };
                document.addEventListener('click', resumeAudio, { once: true, passive: true });
                document.addEventListener('touchend', resumeAudio, { once: true, passive: true });
            }
        } catch (error) {
            console.error("Failed to initialize AudioContext:", error);
            // We can also show a user-friendly alert here if needed
            // showAlert('Audio Error', 'Could not initialize audio for beeps.');
        }
    }

    function initSpeechSynthesis() {
        if ('speechSynthesis' in window) {
            synth = window.speechSynthesis;
            const silentUtterance = new SpeechSynthesisUtterance('');
            silentUtterance.volume = 0;
            silentUtterance.onend = null;
            silentUtterance.onerror = null;
            try {
                // Initial "wake-up" utterance
                synth.speak(silentUtterance);
                console.log('SpeechSynthesis initialized and wake-up utterance sent.');
            } catch (e) {
                console.warn('Initial silent utterance failed (may not be an issue if audio is already active):', e);
            }

            // Ensure voice list is populated when synth is ready
            if (synth.onvoiceschanged !== undefined) {
                synth.onvoiceschanged = () => {
                    // Re-populate voice lists in all active pattern editor instances if open
                    if (!patternEditorContainer.classList.contains('hidden')) {
                        const currentEl = sequencesContainer.firstChild;
                        if (currentEl) {
                            const speechVoiceSelect = currentEl.querySelector('#speechVoiceSelect');
                            if (speechVoiceSelect) {
                                const currentData = sequences[activeSequenceIndex];
                                populateVoiceList(speechVoiceSelect, currentData.speechVoice);
                            }
                        }
                    }
                };
            }
            // Fallback for browsers that might not fire onvoiceschanged immediately
            setTimeout(() => {
                if (!patternEditorContainer.classList.contains('hidden')) {
                    const currentEl = sequencesContainer.firstChild;
                    if (currentEl) {
                        const speechVoiceSelect = currentEl.querySelector('#speechVoiceSelect');
                        if (speechVoiceSelect && synth.getVoices().length > 0 && speechVoiceSelect.options.length <= 1) { // Only if not already populated
                            const currentData = sequences[activeSequenceIndex];
                            populateVoiceList(speechVoiceSelect, currentData.speechVoice);
                        }
                    }
                }
            }, 500); // Small delay to allow voices to load
        } else {
            console.warn('Speech Synthesis API not supported in this browser.');
        }
    }

    function speakSilent() {
        if (!synth || !isRoutineRunning || isPaused) {
            console.log('speakSilent: Conditions not met. isRoutineRunning:', isRoutineRunning, 'isPaused:', isPaused);
            return;
        }

        if (synth.speaking || synth.pending) {
            console.log('speakSilent: Synth busy, skipping silent utterance for now.');
            nextSilentUtteranceTimeout = setTimeout(() => {
                speakSilent();
            }, 100);
            return;
        }

        const utterance = new SpeechSynthesisUtterance('');
        utterance.lang = 'en-US'; // Default lang for silent utterance
        utterance.volume = 0;

        utterance.onend = () => {
            console.log('speakSilent: Silent utterance ended. Scheduling next...');
            if (isRoutineRunning && !isPaused) {
                nextSilentUtteranceTimeout = setTimeout(() => {
                    speakSilent();
                }, 50);
            }
        };

        utterance.onerror = (event) => {
            if (event.error !== 'interrupted') {
                console.error(`speakSilent: Silent speech synthesis error: ${event.error}. Full event:`, event); // Log only real errors as error
                if (isRoutineRunning && !isPaused) {
                    nextSilentUtteranceTimeout = setTimeout(() => {
                        speakSilent();
                    }, 50);
                }
            } else {
                console.info('speakSilent: Silent SpeechSynthesisUtterance was interrupted, which is expected behavior.'); // Log expected interruptions as info
                if (isRoutineRunning && !isPaused) {
                    nextSilentUtteranceTimeout = setTimeout(() => {
                        speakSilent();
                    }, 50);
                }
            }
        };

        try {
            synth.speak(utterance);
            console.log('speakSilent: Silent utterance started.');
        } catch (e) {
            console.error("speakSilent: Error speaking silent utterance directly:", e);
            if (isRoutineRunning && !isPaused) {
                nextSilentUtteranceTimeout = setTimeout(() => {
                    speakSilent();
                }, 50);
            }
        }
    }

    function startSpeechKeepAlive() {
        if (!synth) {
            console.warn('startSpeechKeepAlive: SpeechSynthesis not available for keep-alive.');
            return;
        }
        stopSpeechKeepAlive();
        console.log('startSpeechKeepAlive: Initiating speech keep-alive chain...');
        speakSilent();
    }

    function stopSpeechKeepAlive() {
        if (nextSilentUtteranceTimeout) {
            clearTimeout(nextSilentUtteranceTimeout);
            nextSilentUtteranceTimeout = null;
            console.log('stopSpeechKeepAlive: Cleared nextSilentUtteranceTimeout.');
        }
        if (synth && (synth.speaking || synth.pending)) {
            synth.cancel();
            console.log('stopSpeechKeepAlive: Cancelled existing speech.');
        }
        console.log('stopSpeechKeepAlive: Speech keep-alive stopped and cancelled.');
    }

    function playTwoToneBeep() {
        try {
            if (!audioContext || audioContext.state !== 'running') {
                console.warn("playTwoToneBeep: AudioContext not ready for two-tone beep. State:", audioContext ? audioContext.state : 'null');
                // Attempt to resume it one last time, in case the user interaction happened right before this call
                if(audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                return;
            }

            const duration = 0.15;
            const frequency1 = 800;
            const frequency2 = 1200;
            const volume = 4.0;

            const now = audioContext.currentTime;

            const oscillator1 = audioContext.createOscillator();
            const gainNode1 = audioContext.createGain();
            oscillator1.connect(gainNode1);
            gainNode1.connect(audioContext.destination);
            oscillator1.type = 'sine';
            oscillator1.frequency.setValueAtTime(frequency1, now);
            gainNode1.gain.setValueAtTime(volume, now);
            oscillator1.start(now);
            gainNode1.gain.exponentialRampToValueAtTime(0.00001, now + duration);
            oscillator1.stop(now + duration);

            const oscillator2 = audioContext.createOscillator();
            const gainNode2 = audioContext.createGain();
            oscillator2.connect(gainNode2);
            gainNode2.connect(audioContext.destination);
            oscillator2.type = 'sine';
            oscillator2.frequency.setValueAtTime(frequency2, now + duration);
            gainNode2.gain.setValueAtTime(volume, now + duration);
            oscillator2.start(now + duration);
            gainNode2.gain.exponentialRampToValueAtTime(0.00001, now + duration * 2);
            oscillator2.stop(now + duration * 2);
        } catch (error) {
            console.error("playTwoToneBeep: Error playing two-tone beep:", error);
        }
    }

    // Function to speak with pattern-specific voice and rate
    function speak(text) {
        return new Promise((resolve, reject) => {
            if (!synth) {
                console.warn('speak: Speech Synthesis API not supported or not initialized.');
                reject('Speech Synthesis API not available');
                return;
            }

            if (synth.speaking || synth.pending) {
                synth.cancel();
                if (nextSilentUtteranceTimeout) {
                    clearTimeout(nextSilentUtteranceTimeout);
                    nextSilentUtteranceTimeout = null;
                }
                if (nextAnnouncementTimeout) {
                    clearTimeout(nextAnnouncementTimeout);
                    nextAnnouncementTimeout = null;
                }
                console.log("speak: Cancelled existing speech for new audible message.");
            }

            if (text.trim() === '') {
                resolve(); // Resolve immediately if no text to speak
                return;
            }

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US'; // Fallback language

            // Apply voice and rate from the current pattern being executed
            if (globalSpeechVoice) {
                utterance.voice = globalSpeechVoice;
                utterance.lang = globalSpeechVoice.lang; // Use voice's language
            }
            utterance.rate = globalSpeechRate;
            utterance.volume = 1; // Always full volume for audible speech

            utterance.onend = () => {
                console.log(`speak: Finished speaking: "${text}". Re-initiating silent keep-alive.`);
                if (isRoutineRunning && !isPaused) {
                    startSpeechKeepAlive();
                }
                resolve();
            };
            utterance.onerror = (event) => {
                if (event.error !== 'interrupted') {
                    console.error(`speak: Audible speech synthesis error: ${event.error}. Full event:`, event); // Log only real errors as error
                    // If it's not an expected interruption, then potentially re-schedule keep-alive
                    // Only re-initiate keep-alive if the routine is still running and not paused
                    if (isRoutineRunning && !isPaused) {
                        startSpeechKeepAlive();
                    }
                    reject(new Error(event.error || 'Speech synthesis error')); // Reject with a more informative Error object
                } else {
                    console.info('speak: Audible SpeechSynthesisUtterance was interrupted, which is expected behavior.'); // Log expected interruptions as info
                    // For 'interrupted', still re-schedule keep-alive if routine is running
                    if (isRoutineRunning && !isPaused) {
                        startSpeechKeepAlive();
                    }
                    resolve(); // For 'interrupted', just resolve the promise
                }
            };
            try {
                synth.speak(utterance);
                console.log(`speak: Speaking: "${text}"`);
            } catch (e) {
                console.error("speak: Error speaking audible utterance directly:", e);
                if (isRoutineRunning && !isPaused) {
                    startSpeechKeepAlive();
                }
                reject(e);
            }
        });
    }

    // New: Function to speak with default voice and rate (for countdown/completion)
    function speakDefault(text) {
        return new Promise((resolve, reject) => {
            if (!synth) {
                console.warn('speakDefault: Speech Synthesis API not supported or not initialized.');
                reject('Speech Synthesis API not available');
                return;
            }

            if (synth.speaking || synth.pending) {
                synth.cancel();
                if (nextSilentUtteranceTimeout) {
                    clearTimeout(nextSilentUtteranceTimeout);
                    nextSilentUtteranceTimeout = null;
                }
                if (nextAnnouncementTimeout) {
                    clearTimeout(nextAnnouncementTimeout);
                    nextAnnouncementTimeout = null;
                }
                console.log("speakDefault: Cancelled existing speech for new default message.");
            }

            if (text.trim() === '') {
                resolve(); // Resolve immediately if no text to speak
                return;
            }

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US'; // Explicitly set default language
            utterance.voice = null; // Explicitly set to default system voice
            utterance.rate = 1.0;   // Explicitly set to default rate
            utterance.volume = 1;

            utterance.onend = () => {
                console.log(`speakDefault: Finished speaking: "${text}". Re-initiating silent keep-alive.`);
                if (isRoutineRunning && !isPaused) {
                    startSpeechKeepAlive();
                }
                resolve();
            };
            utterance.onerror = (event) => {
                console.error(`speakDefault: Default speech synthesis error: ${event.error}. Full event:`, event);
                if (event.error !== 'interrupted') {
                    // If it's not an expected interruption, then potentially re-schedule keep-alive
                    // Only re-initiate keep-alive if the routine is still running and not paused
                    if (isRoutineRunning && !isPaused) {
                        startSpeechKeepAlive();
                    }
                    reject(new Error(event.error || 'Speech synthesis error')); // Reject with a more informative Error object
                } else {
                    console.info('speakDefault: Default SpeechSynthesisUtterance was interrupted, which is expected behavior.');
                    // For 'interrupted', still re-schedule keep-alive if routine is running
                    if (isRoutineRunning && !isPaused) {
                        startSpeechKeepAlive();
                    }
                    resolve(); // For 'interrupted', just resolve the promise
                }
            };
            try {
                synth.speak(utterance);
                console.log(`speakDefault: Speaking (default): "${text}"`);
            } catch (e) {
                console.error("speakDefault: Error speaking default utterance:", e);
                if (isRoutineRunning && !isPaused) {
                    startSpeechKeepAlive();
                }
                reject(e);
            }
        });
    }


    async function startWorkout() {
        if (sequences.length === 0) {
            showAlert('Workout Error', 'Please create at least one workout pattern first!');
            return;
        }
        if (!patternEditorContainer.classList.contains('hidden')) {
            saveCurrentSequenceState();
        }
        initAudioContext(); // Ensure it's initialized
        initSpeechSynthesis();
        isRoutineRunning = true;
        startSpeechKeepAlive();

        // Explicitly try to resume the AudioContext right before starting.
        // This is a key change for iOS reliability.
        if (audioContext && audioContext.state === 'suspended') {
            await audioContext.resume();
        }

        if (workoutOrderMode === 'randomized') {
            currentWorkoutPatterns = shuffleArray(sequences);
        } else {
            currentWorkoutPatterns = [...sequences];
        }
        showView('workout');
        currentPatternIndex = 0;
        globalWorkoutTimeElapsed = 0;
        totalWorkoutShots = 0;
        isPaused = false;

        stopWorkoutBtn.innerHTML = `<span class="flex items-center justify-center">${STOP_ICON}</span>`;
        stopWorkoutBtn.onclick = stopWorkout;
        stopWorkoutBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'bg-gray-600', 'hover:bg-gray-700');
        stopWorkoutBtn.classList.add('bg-red-600', 'hover:bg-red-700');

        pauseResumeWorkoutBtn.innerHTML = `<span class="flex items-center justify-center">${PAUSE_ICON}</span>`;
        pauseResumeWorkoutBtn.onclick = togglePauseResume;
        pauseResumeWorkoutBtn.classList.remove('hidden');

        if (workoutCountdownTime > 0) {
            startCountdown(workoutCountdownTime);
        } else {
            runCurrentPattern();
        }
    }

    function startCountdown(timeRemaining) {
        let countdown = timeRemaining;

        const updateCountdownDisplay = () => {
            currentShotDisplay.textContent = countdown;
            progressBar.style.width = `${((timeRemaining - countdown) / timeRemaining) * 100}%`;

            // Announce 10 specifically, then every 10th above 10, and all below 10.
            if (countdown === 10) {
                speakDefault(countdown.toString()).catch(e => console.error('Countdown speech error:', e));
            } else if (countdown > 10) {
                if (countdown % 10 === 0) {
                    speakDefault(countdown.toString()).catch(e => console.error('Countdown speech error:', e));
                }
            } else { // countdown < 10
                speakDefault(countdown.toString()).catch(e => console.error('Countdown speech error:', e));
            }
        };

        // Initial display and announcement
        updateCountdownDisplay();

        countdownTimer = setInterval(() => {
            countdown--;
            if (countdown > 0) {
                updateCountdownDisplay(); // Update and announce next number
            } else {
                clearInterval(countdownTimer);
                countdownTimer = null;
                currentShotDisplay.textContent = 'Go!';
                progressBar.style.width = '100%';
                speakDefault('Go!').catch(e => console.error('Go! speech error:', e)); // Use speakDefault for "Go!"
                setTimeout(runCurrentPattern, 1000); // Start patterns after "Go!"
            }
        }, 1000);
    }

    function stopWorkout() {
        console.log('stopWorkout: Stopping workout...');
        if (countdownTimer) {
            clearInterval(countdownTimer);
            countdownTimer = null;
        }
        if (currentPatternTimer) {
            clearInterval(currentPatternTimer);
            currentPatternTimer = null;
        }
        if (shotIntervalTimer) {
            clearInterval(shotIntervalTimer);
            shotIntervalTimer = null;
        }
        if (flashTimer) {
            clearTimeout(flashTimer);
            flashTimer = null;
        }
        if (nextAnnouncementTimeout) {
            clearTimeout(nextAnnouncementTimeout);
            nextAnnouncementTimeout = null;
        }

        // Revert body background immediately on stop
        document.body.style.backgroundColor = ''; // Clear inline style
        isRoutineRunning = false;
        stopSpeechKeepAlive();
        if(synth) synth.cancel();
        showView('main'); // Return to main view
        calculateTotalWorkoutTime();
        console.log('stopWorkout: Workout stopped.');
    }

    function togglePauseResume() {
        if (isToggleDebouncing) return;
        isToggleDebouncing = true;
        setTimeout(() => { isToggleDebouncing = false; }, DEBOUNCE_TIME);

        if (isPaused) {
            resumeWorkout();
        } else {
            pauseWorkout();
        }
    }

    function pauseWorkout() {
        console.log('pauseWorkout: Pausing workout...');
        isPaused = true;

        if(countdownTimer) {
            clearInterval(countdownTimer);
            countdownTimer = null;
            pausedCountdownTimeRemaining = parseInt(currentShotDisplay.textContent);
        } else {
            pausedShotDisplayContent = currentShotDisplay.textContent;
            if (currentPatternTimer) clearInterval(currentPatternTimer);
            if (shotIntervalTimer) clearInterval(shotIntervalTimer);
            if (flashTimer) clearTimeout(flashTimer);
            if (nextAnnouncementTimeout) clearTimeout(nextAnnouncementTimeout);
            currentPatternTimer = shotIntervalTimer = flashTimer = nextAnnouncementTimeout = null;
        }

        stopSpeechKeepAlive();
        // Revert body background immediately on pause
        document.body.style.backgroundColor = ''; // Clear inline style
        if(synth) synth.cancel();

        pauseResumeWorkoutBtn.innerHTML = `<span class="flex items-center justify-center">${PLAY_ICON}</span>`; // Change to Play icon
        currentShotDisplay.textContent = 'Paused';
        // Do not reset progress bar here for better UX when resuming
        console.log('pauseWorkout: Workout paused.');
    }

    function resumeWorkout() {
        console.log('resumeWorkout: Resuming workout...');
        isPaused = false;
        pauseResumeWorkoutBtn.innerHTML = `<span class="flex items-center justify-center">${PAUSE_ICON}</span>`;
        startSpeechKeepAlive();

        if (pausedCountdownTimeRemaining > 0) {
            startCountdown(pausedCountdownTimeRemaining);
            pausedCountdownTimeRemaining = 0;
        } else if (pausedShotDisplayContent === 'Rest!') {
            let restRemaining = pausedRestTimeRemaining;
            currentShotDisplay.textContent = 'Rest!';
            progressBar.style.width = '100%'; // Progress bar full for rest period
            // Removed redundant 'let' declaration for restRemaining here.
            shotIntervalTimer = setInterval(() => {
                if (isPaused) {
                    clearInterval(shotIntervalTimer);
                    return;
                }
                restRemaining--;
                globalWorkoutTimeElapsed++;
                if (globalLimitType === 'time' && globalWorkoutTimeElapsed >= globalTimeLimit) {
                    clearInterval(shotIntervalTimer);
                    handleWorkoutCompletion();
                    return;
                }
                pausedRestTimeRemaining = restRemaining;
                if (restRemaining <= 0) {
                    clearInterval(shotIntervalTimer);
                    shotIntervalTimer = null;
                    currentPatternIndex++;
                    runCurrentPattern();
                }
            }, 1000);
        } else {
            startShotInterval(currentWorkoutPatterns[currentPatternIndex], pausedTimePassed, pausedEffectiveInterval, pausedShotDisplayContent);
        }
    }

    async function runCurrentPattern() {
        if (isPaused) {
            console.log('runCurrentPattern: PAUSED, returning immediately.');
            return;
        }

        // Check if we've gone past the end of the patterns list
        if (currentPatternIndex >= currentWorkoutPatterns.length) {
            // Check if a global limit is set and not yet reached, requiring a loop.
            const needsToLoop = (globalLimitType === 'shot' && totalWorkoutShots < globalShotLimit) ||
                                (globalLimitType === 'time' && globalWorkoutTimeElapsed < globalTimeLimit);

            if (needsToLoop) {
                console.log("Global limit not reached. Looping patterns.");
                currentPatternIndex = 0; // Reset index to loop from the beginning
                if (workoutOrderMode === 'randomized') {
                    currentWorkoutPatterns = shuffleArray(sequences); // Re-shuffle for the next loop
                    console.log("Re-shuffled patterns for next loop.");
                }
                // Fall-through to re-run with index 0
            } else {
                // No more loops needed, workout is complete.
                console.log('runCurrentPattern: All patterns completed and global limit met (or not set). Ending workout.');
                await handleWorkoutCompletion();
                return; // Exit function
            }
        }

        const pattern = currentWorkoutPatterns[currentPatternIndex];

        // Set global speech properties from the current pattern for workout routines
        globalSpeechRate = pattern.speechRate || 1.0;
        const selectedVoiceName = pattern.speechVoice;
        const voices = synth.getVoices();
        globalSpeechVoice = (selectedVoiceName && selectedVoiceName !== 'default') ?
                            voices.find(voice => voice.name === selectedVoiceName) : null;


        // Check if the current pattern is valid and has shots
        if (pattern && typeof pattern.shotOptions === 'string') {
            const shots = pattern.shotOptions.split('\n').filter(option => option.trim() !== '');
            if (shots.length > 0) {
                // Found a valid pattern with shots, so execute it.
                console.log(`runCurrentPattern: Starting pattern ${currentPatternIndex}: "${pattern.patternName}"`);
                await startPatternExecution(pattern, shots); // Await for intro message to finish
                return; // Exit, the pattern is now running.
            }
        }

        // If pattern is invalid or has no shots, skip to the next one.
        console.log(`runCurrentPattern: Skipping pattern ${currentPatternIndex} as it is invalid or has no shots.`);
        currentPatternIndex++;
        runCurrentPattern(); // Recursively call to process the next index.
    }


    async function startPatternExecution(pattern, shots) {
        currentShotOptions = shots;
        if (pattern.seriesOrder === 'randomized') {
            currentShotOptions = shuffleArray(currentShotOptions);
        }
        currentPatternShotCount = 0;
        currentPatternTimeElapsed = 0;

        if (pattern.announceShots && pattern.introMessage.trim()) {
            currentShotDisplay.textContent = 'Starting...'; // Display message during intro
            progressBar.style.width = '0%'; // Reset progress bar for next pattern
            await speak(pattern.introMessage).catch(e => console.error('Intro message speech error:', e)); // Wait for intro message to finish
        }

        const firstShotToDisplay = currentShotOptions[0];
        currentShotIndex = 1 % currentShotOptions.length;
        if (pattern.seriesOrder === 'randomized' && currentShotIndex === 0) {
            currentShotOptions = shuffleArray(currentShotOptions);
        }
        startShotInterval(pattern, 0, -1, firstShotToDisplay);
    }

    function startShotInterval(pattern, initialTimePassed = 0, totalInterval = -1, shotToDisplayAtStart = null) {
        if (isPaused) return;

        if (currentPatternTimer) clearInterval(currentPatternTimer);
        if (shotIntervalTimer) clearInterval(shotIntervalTimer);
        if (flashTimer) clearTimeout(flashTimer);
        if (nextAnnouncementTimeout) clearTimeout(nextAnnouncementTimeout);

        const baseInterval = parseFloat(pattern.shotInterval);
        const randomOffset = parseFloat(pattern.randomOffset);
        const nextShotAnnouncementTime = parseFloat(pattern.nextShotAnnouncement);

        let effectiveInterval = (totalInterval > 0) ? totalInterval : (baseInterval + (Math.random() * randomOffset));
        let timePassed = initialTimePassed;

        pausedEffectiveInterval = effectiveInterval;
        pausedTimePassed = initialTimePassed;

        const currentDisplayedShot = (shotToDisplayAtStart !== null) ? shotToDisplayAtStart : pausedShotDisplayContent;
        currentShotDisplay.textContent = currentDisplayedShot;

        // This block is for triggering the beep/flash *at the start of each interval* (i.e., for the NEXT shot)
        if (initialTimePassed === 0) {
            playTwoToneBeep();
            flashScreenRed();
        }

        let announcementSpokenForThisInterval = false;
        if (pattern.announceShots && nextShotAnnouncementTime > 0) {
            const delay = (initialTimePassed < nextShotAnnouncementTime) ? (nextShotAnnouncementTime - initialTimePassed) * 1000 : 0;
            if(delay > 0){
                nextAnnouncementTimeout = setTimeout(() => {
                    if (!isPaused && currentShotDisplay.textContent === currentDisplayedShot && currentDisplayedShot.trim() !== '') {
                        speak(currentDisplayedShot).catch(e => console.error('Shot announcement speech error:', e)); // Use speak for pattern-specific announcements
                        announcementSpokenForThisInterval = true;
                    }
                }, delay);
            }
        }

        currentPatternTimer = setInterval(() => {
            if (isPaused) {
                clearInterval(currentPatternTimer);
                return;
            }
            timePassed += 0.1;
            currentPatternTimeElapsed += 0.1;
            globalWorkoutTimeElapsed += 0.1;
            pausedTimePassed = timePassed;

            const progress = (timePassed / effectiveInterval) * 100;
            progressBar.style.width = `${progress}%`;

            if (globalLimitType === 'time' && globalWorkoutTimeElapsed >= globalTimeLimit) {
                handleWorkoutCompletion();
                return;
            }

            if (timePassed >= effectiveInterval) {
                clearInterval(currentPatternTimer);
                currentPatternShotCount++;
                totalWorkoutShots++;

                if (shouldEndPattern(pattern)) {
                    endPattern(pattern); // Call endPattern when pattern is finished
                    return;
                }

                const nextShotToDisplay = currentShotOptions[currentShotIndex];
                currentShotIndex = (currentShotIndex + 1) % currentShotOptions.length;
                if (pattern.seriesOrder === 'randomized' && currentShotIndex === 0) {
                    currentShotOptions = shuffleArray(currentShotOptions);
                }

                // Recursively call to start the next shot interval, triggering its beep/flash at initialTimePassed === 0
                startShotInterval(pattern, 0, -1, nextShotToDisplay);
            }
        }, 100);
    }


    function shouldEndPattern(pattern) {
        if (globalLimitType === 'shot' && totalWorkoutShots >= globalShotLimit) {
            return true;
        }
        if (pattern.limitType === 'shot' && currentPatternShotCount >= pattern.patternLimit) {
            return true;
        }
        if (pattern.limitType === 'time' && currentPatternTimeElapsed >= pattern.patternLimit) {
            return true;
        }
        return false;
    }

    async function endPattern(pattern) {
        if (currentPatternTimer) { clearInterval(currentPatternTimer); }
        if (shotIntervalTimer) { clearInterval(shotIntervalTimer); }
        if (flashTimer) { clearTimeout(flashTimer); }
        if (nextAnnouncementTimeout) { clearTimeout(nextAnnouncementTimeout); }
        document.body.style.backgroundColor = ''; // Clear inline style
        if(synth) synth.cancel();

        // ** Fix Start: Play beep and flash immediately for the last shot **
        playTwoToneBeep();
        flashScreenRed();
        // ** Fix End **

        // Add a small, guaranteed delay after the last shot's beep/flash before any outro or rest.
        await new Promise(resolve => setTimeout(resolve, 500));

        if (pattern.announceShots && pattern.outroMessage.trim()) {
            currentShotDisplay.textContent = 'Finishing...'; // Display message during outro
            progressBar.style.width = '100%'; // Mark pattern as complete visually
            await speak(pattern.outroMessage).catch(e => console.error('Outro message speech error:', e)); // Wait for outro message to finish
        }

        const postRestTime = parseInt(pattern.postSequenceRest);
        if (postRestTime > 0) {
            currentShotDisplay.textContent = "Rest!";
            progressBar.style.width = '100%'; // Progress bar full for rest period
            let restRemaining = postRestTime;
            pausedRestTimeRemaining = restRemaining;
            shotIntervalTimer = setInterval(() => {
                if (isPaused) {
                    clearInterval(shotIntervalTimer);
                    return;
                }
                restRemaining--;
                globalWorkoutTimeElapsed++;
                if (globalLimitType === 'time' && globalWorkoutTimeElapsed >= globalTimeLimit) {
                    clearInterval(shotIntervalTimer);
                    handleWorkoutCompletion();
                    return;
                }
                pausedRestTimeRemaining = restRemaining;
                if (restRemaining <= 0) {
                    clearInterval(shotIntervalTimer);
                    shotIntervalTimer = null;
                    currentPatternIndex++;
                    runCurrentPattern();
                }
            }, 1000);
        } else {
            currentPatternIndex++;
            runCurrentPattern();
        }
    }

    async function handleWorkoutCompletion() {
        if (currentPatternTimer) { clearInterval(currentPatternTimer); }
        if (shotIntervalTimer) { clearInterval(shotIntervalTimer); }
        if (flashTimer) { clearTimeout(flashTimer); }
        if (nextAnnouncementTimeout) { clearTimeout(nextAnnouncementTimeout); }
        document.body.style.backgroundColor = ''; // Clear inline style

        isRoutineRunning = false;
        stopSpeechKeepAlive();
        if(synth) synth.cancel();

        await speakDefault('Workout complete').catch(e => console.error('Workout complete speech error:', e)); // Wait for workout completion announcement

        currentShotDisplay.textContent = 'Done';
        progressBar.style.width = '100%';

        pauseResumeWorkoutBtn.innerHTML = `<span class="flex items-center justify-center">${REPLAY_ICON}</span>`;
        pauseResumeWorkoutBtn.onclick = null;
        pauseResumeWorkoutBtn.addEventListener('click', () => {
            currentPatternIndex = 0;
            if (workoutOrderMode === 'randomized') {
                currentWorkoutPatterns = shuffleArray(sequences);
            } else {
                currentWorkoutPatterns = [...sequences];
            }
            startWorkout();
        }, { once: true });
        pauseResumeWorkoutBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
        pauseResumeWorkoutBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');

        stopWorkoutBtn.innerHTML = `<span class="flex items-center justify-center">${EXIT_ICON}</span>`;
        stopWorkoutBtn.onclick = null;
        stopWorkoutBtn.addEventListener('click', stopWorkout, { once: true });
        stopWorkoutBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
        stopWorkoutBtn.classList.add('bg-gray-600', 'hover:bg-gray-700');
    }

    function flashScreenRed() {
        if (isPaused) { return; }

        // Apply the flash color directly using the Tailwind red-500 hex value
        document.body.style.backgroundColor = '#ef4444';

        // Clear any existing flash timer to prevent conflicts
        if (flashTimer) clearTimeout(flashTimer);

        // Schedule restoration of the original background after a short flash duration
        const flashDurationMs = 150; // Keep the visual flash very short
        flashTimer = setTimeout(() => {
            // Clear the inline style to let the original Tailwind classes re-apply
            document.body.style.backgroundColor = '';
            flashTimer = null;
        }, flashDurationMs);
    }

    function shuffleArray(array) {
        const shuffledArray = [...array];
        for (let i = shuffledArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffledArray[i], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i]];
        }
        return shuffledArray;
    }

      // --- THEME-BASED BANNER FOOTER IMAGE LOGIC ---
      const updateImages = () => {
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches || document.body.classList.contains('dark');
          if (isDarkMode) {
              appBanner.src = 'banner-black.png';
              appFooter.src = 'footer-black.png';
          } else {
              appBanner.src = 'banner-white.png';
              appFooter.src = 'footer-white.png';
          }
      };

      // Observe changes to system color scheme and also manual dark mode toggle (if any)
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
          updateImages();
      });
      // Also keep the MutationObserver for cases where the 'dark' class is manually toggled on the body
      const bodyClassObserver = new MutationObserver((mutationsList) => {
          for (const mutation of mutationsList) {
              if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                  updateImages();
              }
          }
      });
      bodyClassObserver.observe(document.body, { attributes: true });


      // --- EVENT LISTENERS ---

      const updateGlobalLimitControls = () => {
        globalLimitType = globalLimitTypeSelect.value;
        globalShotLimitControls.classList.toggle('hidden', globalLimitType !== 'shot');
        globalTimeLimitControls.classList.toggle('hidden', globalLimitType !== 'time');

        if (globalLimitType === 'shot') {
            // Recalculate minimum shot limit based on accumulated pattern shots if individual limits are shot-based
            const minShots = sequences.reduce((sum, p) => sum + (p.limitType === 'shot' ? p.patternLimit : 0), 0);
            globalShotLimitSlider.min = minShots;
            if (globalShotLimit < minShots) {
                globalShotLimit = minShots;
            }
            globalShotLimitSlider.value = globalShotLimit;
            globalShotLimitDisplay.textContent = `${globalShotLimit} shots`;
        } else if (globalLimitType === 'time') {
            // Recalculate minimum time limit based on accumulated pattern times if individual limits are time-based
            const minTime = sequences.reduce((sum, p) => sum + (p.limitType === 'time' ? p.patternLimit : 0), 0);
            globalTimeLimitSlider.min = minTime > 0 ? minTime : 60; // Ensure minimum of 60 seconds if no time-based patterns
            if (globalTimeLimit < globalTimeLimitSlider.min) {
                globalLimit = parseInt(globalTimeLimitSlider.min);
            }
            globalTimeLimitSlider.value = globalTimeLimit;
            globalTimeLimitDisplay.textContent = formatTime(globalTimeLimit);
        }
        calculateTotalWorkoutTime();
      };

      // Countdown slider
      workoutCountdownSlider.addEventListener('input', (e) => {
        workoutCountdownTime = parseInt(e.target.value);
        workoutCountdownDisplay.textContent = `${workoutCountdownTime}s`;
        calculateTotalWorkoutTime();
      });

      // Global Limit Controls
      globalLimitTypeSelect.addEventListener('change', updateGlobalLimitControls);
      globalShotLimitSlider.addEventListener('input', (e) => {
          globalShotLimit = parseInt(e.target.value);
          globalShotLimitDisplay.textContent = `${globalShotLimit} shots`;
          calculateTotalWorkoutTime(); // Update total time on shot limit change
      });
      globalTimeLimitSlider.addEventListener('input', (e) => {
          globalTimeLimit = parseInt(e.target.value);
          globalTimeLimitDisplay.textContent = formatTime(globalTimeLimit);
          calculateTotalWorkoutTime();
      });

      // Global click listener to turn off modes if an unrelated element is clicked
      document.addEventListener('click', (e) => {
          if (isMoveModeOn || isDeleteModeOn) {
              if (
                  !movePatternToggleButton.contains(e.target) &&
                  !deletePatternToggleButton.contains(e.target) &&
                  !patternsAccordionContainer.contains(e.target) &&
                  !e.target.closest('#confirmation-modal') &&
                  !e.target.closest('#alert-modal') &&
                  e.target !== startWorkoutButton &&
                  !startWorkoutButton.contains(e.target) &&
                  !workoutViewContainer.contains(e.target)
              ) {
                  setInteractionMode(null);
              }
          }
      });


      // Main Action Buttons (New, Move Toggle, Delete Toggle)
      newPatternBtn.addEventListener('click', () => {
        addSequence();
      });

      movePatternToggleButton.addEventListener('click', () => {
          setInteractionMode(isMoveModeOn ? null : 'move');
      });

      deletePatternToggleButton.addEventListener('click', () => {
          setInteractionMode(isDeleteModeOn ? null : 'delete');
      });


      // Event delegation for accordion container clicks (List View)
      patternsAccordionContainer.addEventListener('click', (e) => {
          const accordionItem = e.target.closest('.accordion-item');
          if (!accordionItem) return;

          const patternId = parseFloat(accordionItem.dataset.patternId);
          const patternIndex = sequences.findIndex(p => p.id === patternId);
          if (patternIndex === -1) return;

          if (isMoveModeOn) {
              if (e.target.closest('.chevron-up-toggle')) {
                  movePattern(patternIndex, 'up');
              } else if (e.target.closest('.chevron-down-toggle')) {
                  movePattern(patternIndex, 'down');
              }
              e.stopPropagation();
          } else if (isDeleteModeOn) {
              if (e.target.closest('.delete-toggle')) {
                  showConfirmationModalForDelete(patternIndex);
              }
              e.stopPropagation();
          } else {
              // Normal mode: clicking the header (or pattern name) opens the editor
              if (e.target.closest('.pattern-name-display') || e.target.closest('.right-chevron')) {
                  activeSequenceIndex = patternIndex; // Set the active pattern for the editor
                  showView('editor'); // Navigate to editor view
                  e.stopPropagation(); // Prevent any other clicks from propagating
              }
          }
      });


      // Back to List button in editor
      document.getElementById('back-to-list-btn').addEventListener('click', () => {
          saveCurrentSequenceState(); // Save changes from editor
          activeSequenceIndex = -1; // Clear active pattern
          showView('main'); // Go back to main accordion view
      });

      // Event listeners for inputs/changes within the currently rendered editor screen (delegated to sequencesContainer)
      sequencesContainer.addEventListener('input', (e) => {
          if (!patternEditorContainer.classList.contains('hidden') && sequencesContainer.contains(e.target)) {
              const currentEl = sequencesContainer.firstChild; // Get the currently active cloned sequence element
              if (!currentEl) return;

              if (e.target.closest('#limitTypeSelect')) {
                  handleLimitTypeChange(currentEl);
              } else {
                  saveCurrentSequenceState();
              }

              if (e.target.closest('#shotOptions')) updateShotOptionsDisplay(currentEl);
              else if (e.target.closest('#introMessage') || e.target.closest('#outroMessage') || e.target.closest('#announceShots')) updateNarrationDisplay(currentEl);
              else if (e.target.closest('#shotInterval') || e.target.closest('#randomOffset') || e.target.closest('#nextShotAnnouncement')) {
                  updateIntervalDisplay(currentEl);
                  // Recalculate limit if type is time and interval changed
                  if (sequences[activeSequenceIndex].limitType === 'time') {
                     handleLimitTypeChange(currentEl); // This will re-evaluate patternLimit based on new interval
                  }
                  // Also re-evaluate nextShotAnnouncement max if shotInterval changes
                  if (e.target.closest('#shotInterval')) {
                    handleAnnounceShotsChange(currentEl); // Update max for nextShotAnnouncement based on new interval
                  }
              }
              else if (e.target.closest('#patternLimitSlider')) updateLimitsDisplay(currentEl);
              else if (e.target.closest('#postSequenceRest')) updatePostRestDisplay(currentEl);
              else if (e.target.closest('#speechRate')) {
                  const speechRateValueDisplay = currentEl.querySelector('#speechRateValue');
                  if (speechRateValueDisplay) {
                      speechRateValueDisplay.textContent = parseFloat(e.target.value).toFixed(1);
                  }
                  saveCurrentSequenceState(); // Save after updating display
              }
          }
      });
      sequencesContainer.addEventListener('change', (e) => {
          if (!patternEditorContainer.classList.contains('hidden') && sequencesContainer.contains(e.target)) {
              const currentEl = sequencesContainer.firstChild;
              if (!currentEl) return;

              if (e.target.closest('#limitTypeSelect')) {
                  handleLimitTypeChange(currentEl);
              } else {
                  saveCurrentSequenceState();
              }

              if (e.target.name === 'seriesOrder') updateSequencingDisplay(currentEl);
              if (e.target.closest('#announceShots')) handleAnnounceShotsChange(currentEl);
              if (e.target.closest('#speechVoiceSelect')) {
                  saveCurrentSequenceState(); // Save the selected voice
              }
          }
      });

      // Individual pattern action buttons in the editor
      document.getElementById('clone-btn').addEventListener('click', cloneSequence);
      document.getElementById('import-btn').addEventListener('click', importPatternConfig);
      document.getElementById('save-btn').addEventListener('click', savePatternConfig);
      document.getElementById('reset-btn').addEventListener('click', resetCurrentSequence);


      // Global buttons for all patterns
      document.getElementById('load-all-btn').addEventListener('click', loadWorkout);
      document.getElementById('save-all-btn').addEventListener('click', saveWorkout);
      document.getElementById('reset-all-btn').addEventListener('click', clearAllPatterns);

      // --- Workout Buttons Event Listeners ---
      startWorkoutButton.addEventListener('click', startWorkout);
      pauseResumeWorkoutBtn.addEventListener('click', togglePauseResume);

      // New: Event listener for global workout order radio buttons
      globalWorkoutOrderRadios.forEach(radio => {
          radio.addEventListener('change', (e) => {
              workoutOrderMode = e.target.value;
              console.log('Global workout order mode changed to:', workoutOrderMode);
          });
      });


      // --- INITIALIZATION ---
      const initialize = () => {
        if (sequences.length === 0) {
            sequences.push(getNewSequenceData());
            sequences[0].patternName = "Pattern 1";
        }
        activeSequenceIndex = -1; // Start with no pattern active in editor
        selectedPatternId = sequences[0].id; // Select the first pattern by default
        showView('main'); // Start with the main accordion list view
        calculateTotalWorkoutTime();

        // Set initial state of global workout order radios
        globalWorkoutOrderRadios.forEach(radio => {
            if (radio.value === workoutOrderMode) {
                radio.checked = true;
            }
        });

        initAudioContext();
        initSpeechSynthesis();
        updateImages(); // Set initial banner and footer image
      };

      initialize();
    });
  </script>
</body>
</html>
