<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Squash Ghosting Configuration</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Custom font for a clean look */
    body {
      font-family: "Inter", sans-serif;
    }
    /* Style for range input thumb and track */
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #4f46e5; /* Indigo-600 */
      cursor: pointer;
      box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.3); /* Ring around thumb */
      transition: background 0.15s ease-in-out;
      margin-top: -6px; /* Adjust for vertical alignment */
    }
    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #4f46e5; /* Indigo-600 */
      cursor: pointer;
      box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.3);
      transition: background 0.15s ease-in-out;
    }
    input[type="range"]::-webkit-slider-runnable-track {
      width: 100%;
      height: 8px;
      background: #e5e7eb; /* Gray-200 */
      border-radius: 4px;
      cursor: pointer;
    }
    input[type="range"]::-moz-range-track {
      width: 100%;
      height: 8px;
      background: #e5e7eb; /* Gray-200 */
      border-radius: 4px;
      cursor: pointer;
    }
    input[type="range"]:disabled {
        /* No opacity or cursor not-allowed here, as per user request */
        /* But visually, it might still look disabled due to underlying browser styles */
    }
    input[type="range"]:disabled::-webkit-slider-thumb {
        background: #9ca3af; /* Gray-400 */
        box-shadow: none;
    }
    input[type="range"]:disabled::-moz-range-thumb {
        background: #9ca3af; /* Gray-400 */
        box-shadow: none;
    }
    /* Custom styles for accordion items */
    .accordion-item {
        transition: all 0.3s ease-in-out;
        /* Removed border-bottom here, relying on divide-y on parent */
    }
    .accordion-item:last-child {
        border-bottom: none; /* No border for the last item */
        border-bottom-left-radius: 0.5rem; /* rounded-lg */
        border-bottom-right-radius: 0.5rem; /* rounded-lg */
    }
    .accordion-item:first-child {
        border-top-left-radius: 0.5rem; /* rounded-lg */
        border-top-right-radius: 0.5rem; /* rounded-lg */
    }
    .accordion-item.expanded .accordion-header .right-chevron {
        transform: rotate(-90deg); /* Rotate right chevron when expanded */
    }
    /* Selected row styling, adapted for accordion item */
    .selected-row {
        background-color: #e0e7ff; /* Light indigo for selection */
        border-left: 4px solid #4f46e5; /* Accent border */
    }
    .dark .selected-row {
        background-color: #374151; /* Darker gray for dark mode selection */
        border-left-color: #6366f1; /* Dark mode accent */
    }
    /* Hide scrollbars for the main container but allow scrolling */
    #patterns-accordion-container::-webkit-scrollbar {
        display: none;
    }
    #patterns-accordion-container {
        -ms-overflow-style: none;  /* IE and Edge */
        scrollbar-width: none;  /* Firefox */
    }

    /* Fix for "sticky" button effect on iOS Safari */
    button {
      -webkit-tap-highlight-color: transparent;
    }
  </style>
</head>
<body class="flex min-h-screen items-center justify-center p-4 bg-gray-100 dark:bg-gray-900 transition-colors duration-75">

  <div id="app-container" class="w-full">
    <!-- App Title -->
    <h1 id="app-title" class="text-4xl font-extrabold text-gray-900 dark:text-white text-center mb-1">Squash Ghoster</h1>
    <h1 id="fix" class="text-normal text-gray-900 dark:text-white text-center mb-8">update</h1>

    <!-- Start Workout Button (visible in main view) -->
    <div id="start-workout-container" class="mb-6 hidden">
      <button id="start-workout-btn" class="w-full px-6 py-3 bg-green-600 text-white rounded-lg text-lg font-bold hover:bg-green-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105">
        Start (00:00)
      </button>
    </div>

    <!-- Workout View Container -->
    <div id="workout-view-container" class="w-full h-full hidden flex flex-col">
        <!-- Buttons at the top of the workout view -->
        <div class="flex justify-center space-x-4 pt-4 pb-6 w-full">
            <button id="pause-resume-workout-btn" class="px-6 py-3 bg-blue-600 text-white rounded-lg text-lg font-bold hover:bg-blue-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105">
                <span class="flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><rect width="4" height="16" x="14" y="4" rx="1"/><rect width="4" height="16" x="6" y="4" rx="1"/></svg>
                </span>
            </button>
            <button id="stop-workout-btn" class="px-6 py-3 bg-red-600 text-white rounded-lg text-lg font-bold hover:bg-red-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105">
                <span class="flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><rect width="18" height="18" x="3" y="3" rx="2"/></svg>
                </span>
            </button>
        </div>
        <!-- Main content area (shot display and progress bar) - this will flex-grow and center -->
        <div class="flex-grow flex flex-col items-center justify-center px-4 pb-4">
            <h2 id="current-pattern-name" class="text-3xl font-bold text-center text-gray-800 dark:text-white mb-6 hidden"></h2> <!-- Hidden by default -->
            <p id="current-shot-display" class="text-6xl font-extrabold text-indigo-600 dark:text-indigo-400 mt-2 mb-10"></p>
            <div class="w-full max-w-lg bg-gray-200 rounded-full h-4 dark:bg-gray-700 mb-6">
                <div id="progress-bar" class="bg-green-600 h-4 rounded-full transition-all duration-100 ease-linear" style="width: 0%"></div>
            </div>
        </div>
    </div>

    <!-- Main View Container (holds the accordion list of patterns) -->
    <div id="main-view-container" class="w-full bg-white dark:bg-gray-800 rounded-lg shadow-xl overflow-hidden">
        <h2 class="text-xl font-bold text-gray-800 dark:text-white mb-4 p-6">Workout Patterns</h2>

        <!-- Accordion Container - This will be populated dynamically by JavaScript -->
        <div id="patterns-accordion-container" class="divide-y divide-gray-200 dark:divide-gray-700">
            <!-- Pattern accordion items will be dynamically inserted here -->
        </div>

        <div class="flex justify-center space-x-4 p-6 border-t border-gray-200 dark:border-gray-700">
            <!-- Delete Pattern Toggle Button -->
            <button id="delete-pattern-toggle-btn" class="px-4 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600" data-state="off">
                <span class="flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M18 6 6 18M6 6l12 12"/></svg>
                </span>
            </button>
            <button id="move-pattern-toggle-btn" class="px-4 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600" data-state="off">
                <span class="flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="m7 15 5 5 5-5M7 9l5-5 5 5"/></svg>
                </span>
            </button>
            <button id="new-pattern-btn" class="px-4 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105">
                <span class="flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-plus-lg" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2"/></svg>
                </span>
            </button>
        </div>

        <!-- Hidden template for an accordion item in the main list view -->
        <template id="pattern-list-item-template">
            <div class="accordion-item group">
                <!-- Accordion Header -->
                <div class="accordion-header flex items-center justify-between p-4 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 transition duration-150 ease-in-out">
                    <div class="flex items-center space-x-3 flex-grow">
                        <!-- Left Justified Icons (Move/Delete) -->
                        <!-- X icon -->
                        <svg class="h-5 w-5 text-red-500 flex-shrink-0 delete-toggle hidden cursor-pointer" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true">
                            <path d="M18 6 6 18M6 6l12 12"/>
                        </svg>
                        <!-- Up Chevron icon -->
                        <svg class="h-5 w-5 text-gray-500 flex-shrink-0 chevron-up-toggle hidden cursor-pointer" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true">
                            <path d="m18 15-6-6-6 6"/>
                        </svg>
                        <!-- Down Chevron icon -->
                        <svg class="h-5 w-5 text-gray-500 flex-shrink-0 chevron-down-toggle hidden cursor-pointer" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true">
                            <path d="m6 9 6 6 6-6"/>
                        </svg>
                        <span class="pattern-name-display text-lg font-semibold text-gray-800 dark:text-gray-200 flex-grow">Pattern Name</span>
                    </div>
                    <!-- Right Justified Icon (Right Chevron - for visual expand effect, clicking header navigates) -->
                    <svg class="right-chevron h-5 w-5 text-gray-400 flex-shrink-0 transition-transform duration-150 ease-in-out" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true">
                        <path d="m9 18 6-6-6-6"/>
                    </svg>
                </div>
                <!-- This body will be minimal/empty as editor is separate -->
                <div class="accordion-body hidden p-4 text-sm text-gray-600 dark:text-gray-400">
                    <!-- Summary info can go here if desired, e.g., Shots: 20, Interval: 6s -->
                    <span class="pattern-summary"></span>
                </div>
            </div>
        </template>
    </div>

    <!-- Pattern Editor Container (separate screen) -->
    <div id="pattern-editor-container" class="w-full bg-white dark:bg-gray-800 hidden rounded-lg shadow-xl p-6">
        <!-- Back to List Button -->
        <div class="mb-4">
            <button id="back-to-list-btn" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-arrow-left" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 0 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8"/></svg>
                <span class="text-sm">Back to List</span>
            </button>
        </div>

        <!-- This div will contain the dynamically generated editor for the active pattern -->
        <div id="active-pattern-editor-content">
            <!-- New editable pattern name - Left Justified -->
            <h3 id="editor-pattern-name-display" class="text-xl font-bold text-indigo-700 dark:text-indigo-300 mb-4 cursor-pointer"></h3>
            
            <div class="space-y-4">
                <!-- Options -->
                <div class="border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden">
                    <div class="p-3 bg-gray-50 dark:bg-gray-700 font-bold text-gray-700 dark:text-gray-300">
                        <span class="flex items-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-list-ul" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M5 11.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m-3 1a1 1 0 1 0 0-2 1 1 0 0 0 0 2m0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2m0 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2"/></svg>
                            Options - <span id="editor-options-count-display" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                        </span>
                    </div>
                    <div class="p-3">
                        <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">Available shot locations or types</p>
                        <textarea id="editor-shot-options-input" class="block w-full rounded-lg border border-gray-300 bg-gray-50 p-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500" rows="4"></textarea>
                    </div>
                </div>

                <!-- Narration -->
                <div class="border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden">
                    <div class="p-3 bg-gray-50 dark:bg-gray-700 font-bold text-gray-700 dark:text-gray-300">
                        <span class="flex items-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chat-left-text" viewBox="0 0 16 16"><path d="M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2z"/><path d="M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5M3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6m0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5"/></svg>
                            Narration - <span id="editor-narration-display" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                        </span>
                    </div>
                    <div class="p-3">
                        <div class="mb-4"><label class="inline-flex items-center"><input type="checkbox" id="editor-announce-shots-checkbox" class="form-checkbox rounded text-blue-600 focus:ring-blue-500" /><span class="ml-2 text-gray-700 dark:text-gray-300">Announce shots</span></label></div>
                        <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">Optional message before pattern starts</p>
                        <textarea id="editor-intro-message-input" class="block w-full rounded-lg border border-gray-300 bg-gray-50 p-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500" rows="2"></textarea>
                        <p class="mb-2 mt-4 text-sm font-normal text-gray-500 dark:text-gray-400">Optional message after pattern ends</p>
                        <textarea id="editor-outro-message-input" class="block w-full rounded-lg border border-gray-300 bg-gray-50 p-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500" rows="2"></textarea>
                    </div>
                </div>

                <!-- Sequencing -->
                <div class="border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden">
                    <div class="p-3 bg-gray-50 dark:bg-gray-700 font-bold text-gray-700 dark:text-gray-300">
                        <span class="flex items-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-bar-chart-steps" viewBox="0 0 16 16"><path d="M.5 0a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-1 0V.5A.5.5 0 0 1 .5 0M2 1.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-4a.5.5 0 0 1-.5-.5zm2 4a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-7a.5.5 0 0 1-.5-.5zm2 4a.5.5 0 0 1 .5-.5h6a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-6a.5.5 0 0 1-.5-.5zm2 4a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-7a.5.5 0 0 1-.5-.5z"/></svg>
                            Sequencing - <span id="editor-sequencing-order-display" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                        </span>
                    </div>
                    <div class="p-3">
                        <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">How to iterate through the pattern options</p>
                        <div class="mb-4 flex flex-wrap items-center justify-start space-x-4">
                            <label class="inline-flex items-center"><input type="radio" name="editorSeriesOrder" value="in-order" class="editor-series-order-radio form-radio rounded-full text-blue-600 focus:ring-blue-500" /><span class="ml-2 text-gray-700 dark:text-gray-300">In order</span></label>
                            <label class="inline-flex items-center"><input type="radio" name="editorSeriesOrder" value="randomized" class="editor-series-order-radio form-radio rounded-full text-blue-600 focus:ring-blue-500" /><span class="ml-2 text-gray-700 dark:text-gray-300">Randomized</span></label>
                        </div>
                    </div>
                </div>

                <!-- Interval -->
                <div class="border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden">
                    <div class="p-3 bg-gray-50 dark:bg-gray-700 font-bold text-gray-700 dark:text-gray-300">
                        <span class="flex items-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-bar-right" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M6 8a.5.5 0 0 0 .5.5h5.793l-2.147 2.146a.5.5 0 0 0 .708.708l3-3a.5.5 0 0 0 0-.708l-3-3a.5.5 0 0 0-.708.708L12.293 7.5H6.5A.5.5 0 0 0 6 8m-2.5 7a.5.5 0 0 1-.5-.5v-13a.5.5 0 0 1 1 0v13a.5.5 0 0 1-.5.5" /></svg>
                            Interval - <span id="editor-interval-combined-display" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                        </span>
                    </div>
                    <div class="p-3">
                        <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">Time between each shot</p>
                        <input type="range" id="editor-shot-interval-slider" class="w-full accent-blue-600" min="3.0" max="8.0" step="0.1" />
                        <p class="mb-2 mt-4 text-sm font-normal text-gray-500 dark:text-gray-400">Shot interval fuzz</p>
                        <input type="range" id="editor-random-offset-slider" class="w-full accent-blue-600" min="0.0" max="1.0" step="0.1" />
                        <p class="mb-2 mt-4 text-sm font-normal text-gray-500 dark:text-gray-400">Next shot announcement</p>
                        <input type="range" id="editor-next-shot-announcement-slider" class="w-full accent-blue-600" min="0.0" max="7.0" step="0.1" />
                    </div>
                </div>

                <!-- Limits -->
                <div class="border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden">
                    <div class="p-3 bg-gray-50 dark:bg-gray-700 font-bold text-gray-700 dark:text-gray-300">
                        <span class="flex items-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-123" viewBox="0 0 16 16"><path d="M2.873 11.297V4.142H1.699L0 5.379v1.137l1.64-1.18h.06v5.961zm3.213-5.09v-.063c0-.618.44-1.169 1.196-1.169.676 0 1.174.44 1.174 1.106 0 .624-.42 1.101-.807 1.526L4.99 10.553v.744h4.78v-.99H6.643v-.069L8.41 8.252c.65-.724 1.237-1.332 1.237-2.27C9.646 4.849 8.723 4 7.308 4c-1.573 0-2.36 1.064-2.36 2.15v.057zm6.559 1.883h.786c.823 0 1.374.481 1.379 1.179.01.707-.55 1.216-1.421 1.21-.77-.005-1.326-.419-1.379-.953h-1.095c.042 1.053.938 1.918 2.464 1.918 1.478 0 2.642-.839 2.62-2.144-.02-1.143-.922-1.651-1.551-1.714v-.063c.535-.09 1.347-.66 1.326-1.678-.026-1.053-.933-1.855-2.359-1.845-1.5.005-2.317.88-2.348 1.898h1.116c.032-.498.498-.944 1.206-.944.703 0 1.206.435 1.206 1.07.005.64-.504 1.106-1.2 1.106h-.75z"/></svg>
                            Limits - <span id="editor-limits-display" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                        </span>
                    </div>
                    <div class="p-3">
                        <div class="mb-4">
                            <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">Pattern bounds</p>
                            <select id="editor-limit-type-select" class="block w-full rounded-lg border border-gray-300 bg-gray-50 p-2.5 text-sm text-gray-900 focus:border-blue-500 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500">
                                <option value="shot">Max Shots</option>
                                <option value="time">Max Time</option>
                            </select>
                        </div>
                        <input type="range" id="editor-pattern-limit-slider" class="w-full accent-blue-600 mt-2" min="0" max="100" />
                    </div>
                </div>

                <!-- Post Pattern Rest -->
                <div class="border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden">
                    <div class="p-3 bg-gray-50 dark:bg-gray-700 font-bold text-gray-700 dark:text-gray-300">
                        <span class="flex items-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-heart-pulse" viewBox="0 0 16 16"><path d="m8 2.748-.717-.737C5.6.281 2.514.878 1.4 3.053.918 3.995.78 5.323 1.508 7H.43c-2.128-5.697 4.165-8.83 7.394-5.857q.09.083.176.171a3 3 0 0 1 .176-.17c3.23-2.974 9.522.159 7.394 5.856h-1.078c.728-1.677.59-3.005.108-3.947C13.486.878 10.4.28 8.717 2.01zM2.212 10h1.315C4.593 11.183 6.05 12.458 8 13.795c1.949-1.337 3.407-2.612 4.473-3.795h1.315c-1.265 1.566-3.14 3.25-5.788 5-2.648-1.75-4.523-3.434-5.788-5"/><path d="M10.464 3.314a.5.5 0 0 0-.945.049L7.921 8.956 6.464 5.314a.5.5 0 0 0-.88-.091L3.732 8H.5a.5.5 0 0 0 0 1H4a.5.5 0 0 0 .416-.223l1.473-2.209 1.647 4.118a.5.5 0 0 0 .945-.049l1.598-5.593 1.457 3.642A.5.5 0 0 0 12 9h3.5a.5.5 0 0 0 0-1h-3.162z"/></svg>
                            Post Pattern Rest - <span id="editor-post-sequence-rest-display" class="font-normal text-indigo-600 dark:text-indigo-400"></span>
                        </span>
                    </div>
                    <div class="p-3">
                        <p class="mb-2 text-sm font-normal text-gray-500 dark:text-gray-400">Resting period after this pattern</p>
                        <input type="range" id="editor-post-sequence-rest-slider" class="w-full accent-blue-600" min="0" max="300" />
                    </div>
                </div>
            </div>
            <!-- Centered row of icon buttons - For current pattern in editor -->
            <div class="flex justify-center space-x-4 mt-8">
                <button id="clone-btn" class="flex flex-col items-center p-1 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M15 12v6m-3-3h6"/><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>
                    <span class="text-xs mt-1">Clone</span>
                </button>
                <button id="import-btn" class="flex flex-col items-center p-1 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2"/></svg>
                    <span class="text-xs mt-1">Import</span>
                </button>
                <button id="save-btn" class="flex flex-col items-center p-1 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z"/><path d="M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7M7 3v4a1 1 0 0 0 1 1h7"/></svg>
                    <span class="text-xs mt-1">Save</span>
                </button>
                <button id="reset-btn" class="flex flex-col items-center p-1 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                    <span class="text-xs mt-1">Reset</span>
                </button>
            </div>
        </div>
    </div>


    <!-- Global Controls for all patterns -->
    <div id="global-controls" class="flex justify-center space-x-4 mt-8 hidden">
        <button id="load-all-btn" class="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 w-32">Load</button>
        <button id="save-all-btn" class="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 w-32">Save</button>
        <button id="reset-all-btn" class="px-6 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700 shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 w-32">Reset All</button>
    </div>

    <!-- The Confirmation Modal (for delete/reset) -->
    <div id="confirmation-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 hidden">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm">
            <h3 id="modal-title" class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Confirm Deletion</h3>
            <p id="modal-text" class="text-sm text-gray-600 dark:text-gray-300 mb-6">Are you sure you want to delete this pattern? This action cannot be undone.</p>
            <div class="flex justify-end space-x-4">
                <button id="cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 dark:bg-gray-600 dark:text-gray-200 dark:hover:bg-gray-500">Cancel</button>
                <button id="confirm-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Delete</button>
            </div>
        </div>
    </div>

    <!-- Custom Alert Modal -->
    <div id="alert-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 hidden">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm">
            <h3 id="alert-title" class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Alert</h3>
            <p id="alert-message" class="text-sm text-gray-600 dark:text-gray-300 mb-6"></p>
            <div class="flex justify-end">
                <button id="alert-ok-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">OK</button>
            </div>
        </div>
    </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // --- STATE MANAGEMENT ---
      let sequences = [];
      let activePatternId = null; // Stores the ID of the pattern being edited in the *separate editor*
      let isMoveModeOn = false; // State for move mode in the accordion list
      let isDeleteModeOn = false; // State for delete mode in the accordion list

      const mainViewContainer = document.getElementById('main-view-container');
      const patternsAccordionContainer = document.getElementById('patterns-accordion-container');
      const patternListItemTemplate = document.getElementById('pattern-list-item-template'); // Template for list items
      const patternEditorContainer = document.getElementById('pattern-editor-container'); // The dedicated editor screen
      const activePatternEditorContent = document.getElementById('active-pattern-editor-content'); // Container for editor inputs

      const appContainer = document.getElementById('app-container');
      const globalControls = document.getElementById('global-controls');
      const movePatternToggleButton = document.getElementById('move-pattern-toggle-btn');
      const deletePatternToggleButton = document.getElementById('delete-pattern-toggle-btn');
      const newPatternBtn = document.getElementById('new-pattern-btn');

      const startWorkoutButton = document.getElementById('start-workout-btn');
      const startWorkoutContainer = document.getElementById('start-workout-container');

      // --- Workout View Elements ---
      const workoutViewContainer = document.getElementById('workout-view-container');
      const stopWorkoutBtn = document.getElementById('stop-workout-btn');
      const pauseResumeWorkoutBtn = document.getElementById('pause-resume-workout-btn');
      const currentShotDisplay = document.getElementById('current-shot-display');
      const progressBar = document.getElementById('progress-bar');
      const currentPatternNameDisplay = document.getElementById('current-pattern-name');
      const appTitle = document.getElementById('app-title');

      // --- Editor Specific Elements (cached for easy access) ---
      let editorPatternNameDisplay;
      let editorShotOptionsInput;
      let editorAnnounceShotsCheckbox;
      let editorIntroMessageInput;
      let editorOutroMessageInput;
      let editorSeriesOrderRadios; // NodeList
      let editorShotIntervalSlider;
      let editorRandomOffsetSlider;
      let editorNextShotAnnouncementSlider;
      let editorLimitTypeSelect;
      let editorPatternLimitSlider;
      let editorPostSequenceRestSlider;
      let editorOptionsCountDisplay;
      let editorNarrationDisplay;
      let editorSequencingOrderDisplay;
      let editorIntervalCombinedDisplay;
      let editorLimitsDisplay;
      let editorPostSequenceRestDisplay;
      // Removed editorPatternNameEditContainer and editorPatternNameInput


      // --- Web Audio API ---
      let audioContext = null;

      // --- Speech Synthesis API ---
      let synth = null;
      let isRoutineRunning = false;
      let nextSilentUtteranceTimeout = null;

      // --- SVG Icons ---
      const PAUSE_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><rect width="4" height="16" x="14" y="4" rx="1"/><rect width="4" height="16" x="6" y="4" rx="1"/></svg>`;
      const PLAY_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="m6 3 14 9-14 9z"/></svg>`;
      const STOP_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><rect width="18" height="18" x="3" y="3" rx="2"/></svg>`;
      const REPLAY_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>`;
      const EXIT_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M13 3h6a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-6M3 3l9 9M3 9V3h6"/></svg>`;


      // --- UTILITY FUNCTIONS ---
      const formatTime = (totalSeconds) => {
        const roundedSeconds = Math.round(totalSeconds);
        if (roundedSeconds === 0) return 'None';
        const minutes = Math.floor(roundedSeconds / 60);
        const seconds = roundedSeconds % 60;
        const formattedMinutes = minutes < 10 ? `0${minutes}` : `${minutes}`;
        const formattedSeconds = seconds < 10 ? `0${seconds}` : `${seconds}`;
        return `${formattedMinutes}:${formattedSeconds}`;
      };

      const getNewSequenceData = () => {
        const defaultShotOptions = 'Front left\nFront right\nMid left\nMid right\nBack left\nBack right';
        const defaultMaxShots = 20;
        const defaultMaxTimeSeconds = 120; // 2 minutes
        return {
          id: Date.now() + Math.random(),
          patternName: 'New Pattern',
          shotOptions: defaultShotOptions,
          announceShots: true,
          introMessage: '',
          outroMessage: '',
          seriesOrder: 'in-order',
          shotInterval: 6.0,
          randomOffset: 0.0,
          nextShotAnnouncement: 3.0,
          limitType: 'shot',
          patternLimit: defaultMaxShots,
          postSequenceRest: 0,
          previousShotLimit: defaultMaxShots,
          previousTimeLimit: defaultMaxTimeSeconds
        };
      };

      const focusOnTop = () => {
        if(appContainer) {
          appContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      };

      const sanitizeFilename = (name) => {
        return name.replace(/[^a-z0-9\s-]/gi, '').replace(/\s+/g, '-');
      };

      const isValidPatternConfig = (data) => {
        const requiredProps = [
          'patternName', 'shotOptions', 'announceShots', 'introMessage', 'outroMessage',
          'seriesOrder', 'shotInterval', 'randomOffset', 'nextShotAnnouncement', 'limitType', 'patternLimit', 'postSequenceRest'
        ];
        const hasAllProps = requiredProps.every(prop => Object.prototype.hasOwnProperty.call(data, prop));
        if (!hasAllProps) return false;
        if (typeof data.patternName !== 'string' ||
            typeof data.shotOptions !== 'string' ||
            typeof data.announceShots !== 'boolean' ||
            typeof data.introMessage !== 'string' ||
            typeof data.outroMessage !== 'string' ||
            !['in-order', 'randomized'].includes(data.seriesOrder) ||
            typeof data.shotInterval !== 'number' ||
            typeof data.randomOffset !== 'number' ||
            typeof data.nextShotAnnouncement !== 'number' ||
            !['shot', 'time'].includes(data.limitType) ||
            typeof data.patternLimit !== 'number' ||
            typeof data.postSequenceRest !== 'number') {
            return false;
        }
        return true;
      };

      const isValidWorkoutFile = (data) => {
        if (!Array.isArray(data)) {
            return false;
        }
        return data.every(pattern => isValidPatternConfig(pattern));
      };

      // Custom Alert Modal
      const alertModal = document.getElementById('alert-modal');
      const alertTitle = document.getElementById('alert-title');
      const alertMessage = document.getElementById('alert-message');
      const alertOkBtn = document.getElementById('alert-ok-btn');

      const showAlert = (title, message) => {
          alertTitle.textContent = title;
          alertMessage.textContent = message;
          alertModal.classList.remove('hidden');
          alertOkBtn.onclick = () => {
              alertModal.classList.add('hidden');
          };
      };

      // Function to set interaction mode (move, delete, or null for off)
      const setInteractionMode = (mode) => {
          const wasMoveModeOn = isMoveModeOn;
          const wasDeleteModeOn = isDeleteModeOn;

          isMoveModeOn = (mode === 'move');
          isDeleteModeOn = (mode === 'delete');

          // Update toggle button visuals
          movePatternToggleButton.classList.toggle('bg-blue-600', isMoveModeOn);
          movePatternToggleButton.classList.toggle('text-white', isMoveModeOn);
          movePatternToggleButton.classList.toggle('bg-gray-200', !isMoveModeOn);
          movePatternToggleButton.classList.toggle('text-gray-700', !isMoveModeOn);
          movePatternToggleButton.classList.toggle('dark:bg-gray-700', !isMoveModeOn);
          movePatternToggleButton.classList.toggle('dark:text-gray-300', !isMoveModeOn);
          movePatternToggleButton.dataset.state = isMoveModeOn ? 'on' : 'off';

          deletePatternToggleButton.classList.toggle('bg-red-600', isDeleteModeOn);
          deletePatternToggleButton.classList.toggle('text-white', isDeleteModeOn);
          deletePatternToggleButton.classList.toggle('bg-gray-200', !isDeleteModeOn);
          deletePatternToggleButton.classList.toggle('text-gray-700', !isDeleteModeOn);
          deletePatternToggleButton.classList.toggle('dark:bg-gray-700', !isDeleteModeOn);
          deletePatternToggleButton.classList.toggle('dark:text-gray-300', !isDeleteModeOn);
          deletePatternToggleButton.dataset.state = isDeleteModeOn ? 'on' : 'off';

          // Only re-render accordion if a mode state actually changed
          if (wasMoveModeOn !== isMoveModeOn || wasDeleteModeOn !== isDeleteModeOn) {
              renderAccordionView(); // Re-render accordion to show/hide specific buttons/icons
          }
          toggleOtherButtons(); // Apply global disabling (no opacity for list view, only editor/global buttons)
      };

      // Function to disable/enable other buttons and elements based on active mode
      const toggleOtherButtons = () => {
          const disableGlobalActions = isMoveModeOn || isDeleteModeOn;

          const loadAllBtn = document.getElementById('load-all-btn');
          const saveAllBtn = document.getElementById('save-all-btn');
          const resetAllBtn = document.getElementById('reset-all-btn');
          const startWorkoutBtn = document.getElementById('start-workout-btn');

          const elementsToToggleDisable = [
              newPatternBtn, loadAllBtn, saveAllBtn, startWorkoutBtn
          ];

          elementsToToggleDisable.forEach(element => {
              if (element) {
                  element.disabled = disableGlobalActions;
                  // NO OPACITY OR CURSOR-NOT-ALLOWED FOR GLOBAL BUTTONS AS PER NEW REQUIREMENT
              }
          });

          // Specific handling for mode toggle buttons (mutually exclusive)
          if (movePatternToggleButton) {
              movePatternToggleButton.disabled = isDeleteModeOn;
          }
          if (deletePatternToggleButton) {
              deletePatternToggleButton.disabled = isMoveModeOn;
          }

          // Global Reset button is special, it's never disabled by these modes
          if (resetAllBtn) {
            resetAllBtn.disabled = false;
          }

          // Disable/enable elements inside the *editor* view if it's visible
          if (!patternEditorContainer.classList.contains('hidden')) {
              const editorInputs = activePatternEditorContent.querySelectorAll('input:not([type="radio"]), textarea, select');
              const editorButtons = activePatternEditorContent.querySelectorAll('#clone-btn, #import-btn, #save-btn, #reset-btn');

              editorInputs.forEach(inputField => {
                  const isInternallyDisabled = (inputField.id === 'editor-next-shot-announcement-slider' && !editorAnnounceShotsCheckbox.checked);
                  inputField.disabled = isInternallyDisabled; // Only internal logic disables
              });

              editorButtons.forEach(btn => {
                  btn.disabled = false; // Editor buttons are always enabled unless explicitly disabled by another means
              });
              
              // Pattern name display in editor
              if (editorPatternNameDisplay) {
                editorPatternNameDisplay.style.pointerEvents = 'auto'; // Always allow editing in editor
              }
          }
      };


      // --- VIEW MANAGEMENT ---
      const showView = (view) => {
          // Reset appContainer styles before applying view-specific ones
          appContainer.classList.remove(
            'max-w-2xl', 'rounded-xl', 'bg-white', 'p-6', 'shadow-lg', 'dark:bg-gray-800',
            'absolute', 'inset-0', 'flex', 'flex-col', 'items-center', 'justify-center'
          );
          document.body.classList.remove('items-center', 'justify-center', 'p-0');

          // Hide all view containers initially
          mainViewContainer.classList.add('hidden');
          startWorkoutContainer.classList.add('hidden');
          globalControls.classList.add('hidden');
          workoutViewContainer.classList.add('hidden');
          patternEditorContainer.classList.add('hidden'); // Ensure editor is hidden
          appTitle.classList.remove('hidden');

          if (view === 'main') {
              appContainer.classList.add('max-w-2xl', 'rounded-xl', 'bg-white', 'p-6', 'shadow-lg', 'dark:bg-gray-800');
              document.body.classList.add('items-center', 'justify-center');
              mainViewContainer.classList.remove('hidden');
              startWorkoutContainer.classList.remove('hidden');
              globalControls.classList.remove('hidden');
              renderAccordionView(); // Render the list
              calculateTotalWorkoutTime();
              focusOnTop();
              setInteractionMode(null); // Ensure modes are off when entering main view
          } else if (view === 'editor') {
              appContainer.classList.add('max-w-2xl', 'rounded-xl', 'bg-white', 'p-6', 'shadow-lg', 'dark:bg-gray-800');
              document.body.classList.add('items-center', 'justify-center');
              patternEditorContainer.classList.remove('hidden');
              populatePatternEditor(); // Populate the editor with activePatternId's data
              focusOnTop();
              // No mode selection in editor, so ensure modes are off
              isMoveModeOn = false;
              isDeleteModeOn = false;
              toggleOtherButtons(); // Update button states based on being in editor
          } else if (view === 'workout') {
              appContainer.classList.add('absolute', 'inset-0', 'flex', 'flex-col');
              document.body.classList.add('p-0');
              workoutViewContainer.classList.remove('hidden');
              focusOnTop();
          }
      };

      // --- ESTIMATED WORKOUT TIME CALCULATION ---
      const calculateTotalWorkoutTime = () => {
          let totalTime = 0;
          sequences.forEach(pattern => {
              let patternDuration = 0;
              if (pattern.limitType === 'time') {
                  patternDuration = pattern.patternLimit;
              } else if (pattern.limitType === 'shot') {
                  patternDuration = pattern.patternLimit * pattern.shotInterval;
              }
              totalTime += patternDuration;
              totalTime += pattern.postSequenceRest;
          });
          startWorkoutButton.textContent = `Start (${formatTime(totalTime)})`;
      };


      // --- ACCORDION LIST VIEW RENDERING ---
      const renderAccordionView = () => {
          patternsAccordionContainer.innerHTML = '';
          if (sequences.length === 0) {
              const noPatternsMessage = document.createElement('div');
              noPatternsMessage.classList.add('p-6', 'text-center', 'text-gray-500', 'dark:text-gray-400');
              noPatternsMessage.textContent = 'No patterns configured. Click the "+" button to add one.';
              patternsAccordionContainer.appendChild(noPatternsMessage);
              return;
          }

          sequences.forEach((pattern, index) => {
              const newAccordionItem = patternListItemTemplate.content.cloneNode(true).firstElementChild;
              newAccordionItem.dataset.patternId = pattern.id;
              newAccordionItem.dataset.index = index;

              const patternNameDisplay = newAccordionItem.querySelector('.pattern-name-display');
              const deleteToggle = newAccordionItem.querySelector('.delete-toggle');
              const chevronUpToggle = newAccordionItem.querySelector('.chevron-up-toggle');
              const chevronDownToggle = newAccordionItem.querySelector('.chevron-down-toggle');
              const accordionHeader = newAccordionItem.querySelector('.accordion-header');
              const patternSummarySpan = newAccordionItem.querySelector('.pattern-summary');

              patternNameDisplay.textContent = pattern.patternName;

              // Update summary text (example summary, customize as needed)
              const limitText = pattern.limitType === 'shot' ? `${pattern.patternLimit} shots` : formatTime(pattern.patternLimit);
              patternSummarySpan.textContent = `Shots: ${pattern.shotOptions.trim().split(/[\n,]+/).filter(Boolean).length}, Limit: ${limitText}, Interval: ${pattern.shotInterval}s`;


              // Set visibility of move/delete icons based on mode
              if (isDeleteModeOn) {
                  deleteToggle.classList.remove('hidden');
              } else {
                  deleteToggle.classList.add('hidden');
              }
              if (isMoveModeOn) {
                  chevronUpToggle.classList.remove('hidden');
                  chevronDownToggle.classList.remove('hidden');
              } else {
                  chevronUpToggle.classList.add('hidden');
                  chevronDownToggle.classList.add('hidden');
              }

              // Disable/enable move arrows based on position
              if (index === 0) {
                  chevronUpToggle.classList.add('opacity-30', 'cursor-not-allowed');
              } else {
                  chevronUpToggle.classList.remove('opacity-30', 'cursor-not-allowed');
              }
              if (index === sequences.length - 1) {
                  chevronDownToggle.classList.add('opacity-30', 'cursor-not-allowed');
              } else {
                  chevronDownToggle.classList.remove('opacity-30', 'cursor-not-allowed');
              }

              // Apply 'selected-row' class if this pattern is currently selected in the list
              // Only apply if no mode is active, otherwise selection is implicit by mode.
              if (activePatternId === pattern.id && !isMoveModeOn && !isDeleteModeOn) {
                newAccordionItem.classList.add('selected-row');
              } else {
                newAccordionItem.classList.remove('selected-row');
              }


              // Add click listener for header to navigate to editor or trigger mode action
              accordionHeader.addEventListener('click', (e) => {
                  const clickedElement = e.target;
                  if (isMoveModeOn) {
                      if (clickedElement.closest('.chevron-up-toggle')) {
                          movePattern(index, 'up');
                      } else if (clickedElement.closest('.chevron-down-toggle')) {
                          movePattern(index, 'down');
                      }
                      e.stopPropagation(); // Prevent navigation/other clicks
                  } else if (isDeleteModeOn) {
                      if (clickedElement.closest('.delete-toggle')) {
                          showConfirmationModalForDelete(index);
                      }
                      e.stopPropagation(); // Prevent navigation/other clicks
                  } else {
                      // Normal mode: clicking the header (or pattern name) opens the editor
                      // We can also make the right chevron click expand/collapse a summary (optional)
                      if (clickedElement.closest('.pattern-name-display') || clickedElement.closest('.right-chevron')) {
                          activePatternId = pattern.id; // Set the active pattern for the editor
                          showView('editor'); // Navigate to editor view
                          e.stopPropagation(); // Prevent any other clicks from propagating
                      }
                  }
              });

              patternsAccordionContainer.appendChild(newAccordionItem);
          });
          toggleOtherButtons(); // Ensure global buttons react to mode changes
      };

      /**
       * Populates the editor view with the data of the currently active pattern.
       */
      const populatePatternEditor = () => {
          const currentPattern = sequences.find(p => p.id === activePatternId);
          if (!currentPattern) {
              showView('main'); // Go back if no active pattern found
              showAlert('Error', 'Could not load pattern editor.');
              return;
          }

          // Cache editor elements if not already cached
          if (!editorPatternNameDisplay) {
            editorPatternNameDisplay = document.getElementById('editor-pattern-name-display');
            editorShotOptionsInput = document.getElementById('editor-shot-options-input');
            editorAnnounceShotsCheckbox = document.getElementById('editor-announce-shots-checkbox');
            editorIntroMessageInput = document.getElementById('editor-intro-message-input');
            editorOutroMessageInput = document.getElementById('editor-outro-message-input');
            editorSeriesOrderRadios = document.querySelectorAll('input[name="editorSeriesOrder"]');
            editorShotIntervalSlider = document.getElementById('editor-shot-interval-slider');
            editorRandomOffsetSlider = document.getElementById('editor-random-offset-slider');
            editorNextShotAnnouncementSlider = document.getElementById('editor-next-shot-announcement-slider');
            editorLimitTypeSelect = document.getElementById('editor-limit-type-select');
            editorPatternLimitSlider = document.getElementById('editor-pattern-limit-slider');
            editorPostSequenceRestSlider = document.getElementById('editor-post-sequence-rest-slider');

            editorOptionsCountDisplay = document.getElementById('editor-options-count-display');
            editorNarrationDisplay = document.getElementById('editor-narration-display');
            editorSequencingOrderDisplay = document.getElementById('editor-sequencing-order-display');
            editorIntervalCombinedDisplay = document.getElementById('editor-interval-combined-display');
            editorLimitsDisplay = document.getElementById('editor-limits-display');
            editorPostSequenceRestDisplay = document.getElementById('editor-post-sequence-rest-display');
          }

          // Set values to editor fields
          editorPatternNameDisplay.textContent = currentPattern.patternName;
          editorShotOptionsInput.value = currentPattern.shotOptions;
          editorAnnounceShotsCheckbox.checked = currentPattern.announceShots;
          editorIntroMessageInput.value = currentPattern.introMessage;
          editorOutroMessageInput.value = currentPattern.outroMessage;
          editorSeriesOrderRadios.forEach(radio => radio.checked = (radio.value === currentPattern.seriesOrder));
          editorShotIntervalSlider.value = currentPattern.shotInterval;
          editorRandomOffsetSlider.value = currentPattern.randomOffset;
          editorNextShotAnnouncementSlider.value = currentPattern.nextShotAnnouncement;
          editorLimitTypeSelect.value = currentPattern.limitType;
          editorPatternLimitSlider.value = currentPattern.patternLimit;
          editorPostSequenceRestSlider.value = currentPattern.postSequenceRest;

          // Apply specific logic for sliders/displays
          handleEditorAnnounceShotsChange(); // Update nextShotAnnouncement max/disabled state
          handleEditorLimitTypeChange(); // Update patternLimitSlider min/max/value based on type
          updateAllEditorDisplays(); // Update all summary texts
      };


      /**
       * Saves the current state of the editor's input fields back to the `sequences` array.
       */
      const saveCurrentPatternState = () => {
          if (!activePatternId) return;

          const patternIndex = sequences.findIndex(p => p.id === activePatternId);
          if (patternIndex === -1) return;

          const currentData = sequences[patternIndex];

          // Save the current patternLimit to the appropriate 'previous' field before updating currentData
          if (currentData.limitType === 'shot') {
              currentData.previousShotLimit = parseInt(editorPatternLimitSlider.value);
          } else if (currentData.limitType === 'time') {
              currentData.previousTimeLimit = parseInt(editorPatternLimitSlider.value);
          }

          // Update pattern data from the editor input fields
          currentData.patternName = editorPatternNameDisplay.textContent; // Get from span, not input during normal operation
          currentData.shotOptions = editorShotOptionsInput.value;
          currentData.announceShots = editorAnnounceShotsCheckbox.checked;
          currentData.introMessage = editorIntroMessageInput.value;
          currentData.outroMessage = editorOutroMessageInput.value;
          currentData.seriesOrder = Array.from(editorSeriesOrderRadios).find(radio => radio.checked).value;
          currentData.shotInterval = parseFloat(editorShotIntervalSlider.value);
          currentData.randomOffset = parseFloat(editorRandomOffsetSlider.value);
          currentData.nextShotAnnouncement = parseFloat(editorNextShotAnnouncementSlider.value);
          currentData.limitType = editorLimitTypeSelect.value;
          currentData.patternLimit = parseInt(editorPatternLimitSlider.value);
          currentData.postSequenceRest = parseInt(editorPostSequenceRestSlider.value);

          calculateTotalWorkoutTime();
      };

      // --- UI UPDATE FUNCTIONS (for the separate editor screen) ---
      const updateAllEditorDisplays = () => {
          updateEditorShotOptionsDisplay();
          updateEditorNarrationDisplay();
          updateEditorSequencingDisplay();
          updateEditorIntervalDisplay();
          updateEditorLimitsDisplay();
          updateEditorPostRestDisplay();
      }

      const updateEditorShotOptionsDisplay = () => {
        const count = editorShotOptionsInput.value.trim().split(/[\n,]+/).filter(Boolean).length;
        editorOptionsCountDisplay.textContent = `${count} shots`;
      };

      const updateEditorNarrationDisplay = () => {
        const parts = [];
        if (editorAnnounceShotsCheckbox.checked) parts.push('Shots');
        if (editorIntroMessageInput.value.trim()) parts.push('Intro');
        if (editorOutroMessageInput.value.trim()) parts.push('Outro');
        editorNarrationDisplay.textContent = parts.length ? parts.join(', ') : 'None';
      };

      const updateEditorSequencingDisplay = () => {
          const value = Array.from(editorSeriesOrderRadios).find(radio => radio.checked).value;
          editorSequencingOrderDisplay.textContent = value === 'in-order' ? 'In order' : 'Randomized';
      };

      const updateEditorIntervalDisplay = () => {
        const interval = parseFloat(editorShotIntervalSlider.value).toFixed(1);
        const offset = parseFloat(editorRandomOffsetSlider.value).toFixed(1);
        const nextShotAnnounce = parseFloat(editorNextShotAnnouncementSlider.value).toFixed(1);

        let text = offset > 0 ? `${interval} sec  ${offset}` : `${interval} sec`;
        if (editorAnnounceShotsCheckbox.checked) {
            text += ` (${nextShotAnnounce}s)`;
        }
        editorIntervalCombinedDisplay.textContent = text;
      };

      const handleEditorAnnounceShotsChange = () => {
          const isChecked = editorAnnounceShotsCheckbox.checked;
          const currentShotInterval = parseFloat(editorShotIntervalSlider.value);

          editorNextShotAnnouncementSlider.disabled = !isChecked;
          editorNextShotAnnouncementSlider.max = Math.max(0, currentShotInterval - 0.1);

          if (parseFloat(editorNextShotAnnouncementSlider.value) > editorNextShotAnnouncementSlider.max) {
              editorNextShotAnnouncementSlider.value = editorNextShotAnnouncementSlider.max;
          }
          // No opacity/cursor-not-allowed as per user request
          updateEditorNarrationDisplay();
          updateEditorIntervalDisplay();
      };


      const handleEditorLimitTypeChange = () => {
        const select = editorLimitTypeSelect;
        const slider = editorPatternLimitSlider;

        const currentPattern = sequences.find(p => p.id === activePatternId);
        if (!currentPattern) return;

        const newLimitType = select.value;
        const prevLimitTypeInState = currentPattern.limitType;

        if (prevLimitTypeInState === 'shot') {
            currentPattern.previousShotLimit = parseInt(slider.value);
        } else if (prevLimitTypeInState === 'time') {
            currentPattern.previousTimeLimit = parseInt(slider.value);
        }

        currentPattern.limitType = newLimitType;

        let proposedValue;
        if (newLimitType === 'shot') {
            slider.min = 0;
            slider.max = 100;
            proposedValue = (typeof currentPattern.previousShotLimit === 'number' && currentPattern.previousShotLimit > 0)
                                ? currentPattern.previousShotLimit
                                : currentPattern.shotOptions.trim().split(/[\n,]+/).filter(Boolean).length;
        } else if (newLimitType === 'time') {
            const shotOptionsCount = currentPattern.shotOptions.trim().split(/[\n,]+/).filter(Boolean).length;
            const estimatedTimeForOptions = shotOptionsCount * currentPattern.shotInterval;

            slider.min = Math.max(1, Math.round(currentPattern.shotInterval));
            slider.max = 1800; // 30 minutes in seconds

            proposedValue = (typeof currentPattern.previousTimeLimit === 'number' && currentPattern.previousTimeLimit > 0)
                                ? currentPattern.previousTimeLimit
                                : Math.round(estimatedTimeForOptions);
        }

        slider.value = Math.min(Math.max(proposedValue, parseInt(slider.min)), parseInt(slider.max));
        currentPattern.patternLimit = parseInt(slider.value);

        updateEditorLimitsDisplay();
        calculateTotalWorkoutTime();
      };

      const updateEditorLimitsDisplay = () => {
        const type = editorLimitTypeSelect.value;
        const value = parseInt(editorPatternLimitSlider.value);
        if (type === 'shot') {
          editorLimitsDisplay.textContent = `${value} shots`;
        } else if (type === 'time') {
          editorLimitsDisplay.textContent = formatTime(value);
        }
      };

      const updateEditorPostRestDisplay = () => {
        const value = parseInt(editorPostSequenceRestSlider.value);
        editorPostSequenceRestDisplay.textContent = formatTime(value);
      };


      // --- SEQUENCE MANAGEMENT FUNCTIONS ---
      const addSequence = () => {
        if (activePatternId) {
            // If an editor was active, save its state before adding new pattern
            // and switch back to main view.
            saveCurrentPatternState();
            activePatternId = null; // Clear active pattern
            showView('main');
        }

        const newSequence = getNewSequenceData();
        newSequence.patternName = `Pattern ${sequences.length + 1}`;
        sequences.push(newSequence);

        // After adding, immediately switch to editing the new pattern
        activePatternId = newSequence.id;
        showView('editor');
        calculateTotalWorkoutTime();
        focusOnTop();
      };

      const cloneSequence = () => {
        const patternToClone = sequences.find(p => p.id === activePatternId);
        if (!patternToClone) {
            showAlert('Clone Error', 'No pattern selected to clone.');
            return;
        }
        saveCurrentPatternState();

        const clonedData = JSON.parse(JSON.stringify(patternToClone));
        clonedData.id = Date.now() + Math.random();
        clonedData.patternName = `${clonedData.patternName} (Clone)`;

        const originalIndex = sequences.findIndex(p => p.id === patternToClone.id);
        if (originalIndex !== -1) {
            sequences.splice(originalIndex + 1, 0, clonedData);
            activePatternId = clonedData.id; // Make the new clone the active pattern in editor
        } else {
            sequences.push(clonedData);
            activePatternId = clonedData.id;
        }

        populatePatternEditor(); // Re-populate editor with cloned data
        calculateTotalWorkoutTime();
        focusOnTop();
      };

      const movePattern = (index, direction) => {
          // No need to save activePatternState here, as move/delete are for list view
          const patternIdToSelect = sequences[index].id;

          if (direction === 'up' && index > 0) {
              [sequences[index], sequences[index - 1]] = [sequences[index - 1], sequences[index]];
          } else if (direction === 'down' && index < sequences.length - 1) {
              [sequences[index], sequences[index + 1]] = [sequences[index + 1], sequences[index]];
          }
          // activePatternId remains the same if it was already selected and not directly moved
          renderAccordionView(); // Re-render the list to show new order
          calculateTotalWorkoutTime();
      };

      const deleteSequence = (indexToDelete) => {
          // If only one pattern, clear and reset instead of deleting entirely
          if (sequences.length <= 1) {
              const currentPatternId = sequences.length > 0 ? sequences[0].id : null;
              sequences = [];
              sequences.push({ ...getNewSequenceData(), id: currentPatternId });
              sequences[0].patternName = "Pattern 1";
              activePatternId = null; // No pattern active after reset
              showAlert('Pattern Reset', 'Last pattern reset to default settings.');
              showView('main'); // Go back to main accordion view
              calculateTotalWorkoutTime();
              return;
          }

          // Perform the deletion
          sequences.splice(indexToDelete, 1);
          activePatternId = null; // Always clear activePatternId on delete from list
          showView('main'); // Always go back to main accordion view after deletion
          calculateTotalWorkoutTime();
          focusOnTop();
      };


      const resetCurrentSequence = () => {
          if (!activePatternId) {
            showAlert('Reset Error', 'No pattern selected to reset.');
            return;
          }
          const patternIndex = sequences.findIndex(p => p.id === activePatternId);
          if (patternIndex === -1) return;

          const currentId = sequences[patternIndex].id;
          sequences[patternIndex] = { ...getNewSequenceData(), id: currentId };
          sequences[patternIndex].patternName = `Pattern ${patternIndex + 1}`;
          populatePatternEditor(); // Re-populate editor with reset data
          calculateTotalWorkoutTime();
      };

      // Function to handle pattern name editing in the editor screen
      const editPatternNameInEditor = () => {
          // Make the display H3 element editable
          editorPatternNameDisplay.contentEditable = "true";
          editorPatternNameDisplay.focus(); // Focus on the editable element
          // Select all text in the editable element (optional, for convenience)
          const range = document.createRange();
          range.selectNodeContents(editorPatternNameDisplay);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);

          const saveAndRevert = () => {
              // Get the new name directly from the content-editable H3
              let newName = editorPatternNameDisplay.textContent.trim();
              if (newName === '') {
                  newName = 'Unnamed Pattern';
              }
              const currentPattern = sequences.find(p => p.id === activePatternId);
              if (currentPattern) {
                  currentPattern.patternName = newName;
              }
              editorPatternNameDisplay.contentEditable = "false"; // Make it non-editable again
              saveCurrentPatternState();
              calculateTotalWorkoutTime();
          };

          const handleKeyDown = (e) => {
              if (e.key === 'Enter') {
                  e.preventDefault(); // Prevent new line from being added
                  saveAndRevert();
                  editorPatternNameDisplay.blur(); // Trigger blur to ensure save and listener removal
              }
          };

          // Add listeners directly to the editorPatternNameDisplay
          editorPatternNameDisplay.addEventListener('blur', saveAndRevert, { once: true });
          editorPatternNameDisplay.addEventListener('keydown', handleKeyDown, { once: true });
      };

      // --- INDIVIDUAL PATTERN IMPORT / SAVE FUNCTIONS (for the separate editor) ---
      const savePatternConfig = () => {
        const patternToSave = sequences.find(p => p.id === activePatternId);
        if (!patternToSave) {
          showAlert('Save Error', 'No pattern selected to save.');
          return;
        }
        saveCurrentPatternState(); // Ensure data is synced from editor fields
        const dataStr = JSON.stringify(patternToSave, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `${sanitizeFilename(patternToSave.patternName)}.pattern.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showAlert('Pattern Saved', `Pattern "${patternToSave.patternName}" saved successfully.`);
        calculateTotalWorkoutTime();
      };

      const importPatternConfig = () => {
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json,.pattern.json';
        fileInput.style.display = 'none';

        fileInput.addEventListener('change', (event) => {
          const file = event.target.files[0];
          if (!file) {
              document.body.removeChild(fileInput);
              return;
          }

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const importedData = JSON.parse(e.target.result);
              if (isValidPatternConfig(importedData)) {
                const patternIndex = sequences.findIndex(p => p.id === activePatternId);
                if (patternIndex !== -1) {
                    sequences[patternIndex] = { ...importedData, id: activePatternId };
                    populatePatternEditor(); // Re-populate editor with imported data
                    showAlert('Pattern Imported', `Pattern "${importedData.patternName}" imported successfully.`);
                } else {
                    showAlert('Import Error', 'No active pattern to import into.');
                }
                calculateTotalWorkoutTime();
              } else {
                showAlert('Import Error', 'Invalid pattern configuration file. Please select a valid .pattern.json file.');
              }
            } catch (error) {
              showAlert('Import Error', 'Failed to parse file. Please ensure it is a valid JSON file.');
            } finally {
              document.body.removeChild(fileInput);
            }
          };
          reader.onerror = () => {
            showAlert('Import Error', 'Failed to read file.');
            document.body.removeChild(fileInput);
          };
          reader.readAsText(file);
        });

        document.body.appendChild(fileInput);
        fileInput.click();
      };


      // --- GLOBAL WORKOUT (ALL PATTERNS) FUNCTIONS ---
      const loadAllPatterns = () => {
        setInteractionMode(null); // Turn off any list modes

        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json,.workout.json';
        fileInput.style.display = 'none';

        fileInput.addEventListener('change', (event) => {
          const file = event.target.files[0];
          if (!file) {
              document.body.removeChild(fileInput);
              return;
          }

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const importedWorkout = JSON.parse(e.target.result);
              if (isValidWorkoutFile(importedWorkout)) {
                sequences = importedWorkout.map(pattern => ({ ...pattern, id: Date.now() + Math.random() }));
                activePatternId = null;
                showView('main'); // Show the main accordion view
                showAlert('Workout Loaded', `Successfully loaded ${sequences.length} patterns.`);
                calculateTotalWorkoutTime();
              } else {
                showAlert('Load Error', 'Invalid workout file. Please select a valid .workout.json file containing an array of patterns.');
              }
            } catch (error) {
              showAlert('Load Error', 'Failed to parse workout file. Please ensure it is a valid JSON file.');
            } finally {
              document.body.removeChild(fileInput);
            }
          };
          reader.onerror = () => {
            showAlert('Load Error', 'Failed to read workout file.');
            document.body.removeChild(fileInput);
          };
          reader.readAsText(file);
        });

        document.body.appendChild(fileInput);
        fileInput.click();
      };

      const saveAllPatterns = () => {
        setInteractionMode(null); // Turn off any list modes
        if (!patternEditorContainer.classList.contains('hidden')) { // If in editor, save current
          saveCurrentPatternState();
        }

        if (sequences.length === 0) {
            showAlert('Save Error', 'No patterns to save in the workout file.');
            return;
        }
        const dataStr = JSON.stringify(sequences, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `my-workout-${new Date().toISOString().slice(0,10)}.workout.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showAlert('Workout Saved', `Successfully saved ${sequences.length} patterns to a workout file.`);
        calculateTotalWorkoutTime();
      };

      const clearAllPatterns = () => {
          setInteractionMode(null); // Turn off any list modes

          const modal = document.getElementById('confirmation-modal');
          const modalTitle = document.getElementById('modal-title');
          const modalText = document.getElementById('modal-text');
          const confirmBtn = document.getElementById('confirm-btn');
          const cancelBtn = document.getElementById('cancel-btn');

          modalTitle.textContent = 'Confirm Reset';
          modalText.textContent = 'Are you sure you want to clear all workout patterns? This action cannot be undone.';
          confirmBtn.textContent = 'Reset';
          confirmBtn.className = 'px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700';
          modal.classList.remove('hidden');

          confirmBtn.replaceWith(confirmBtn.cloneNode(true));
          cancelBtn.replaceWith(cancelBtn.cloneNode(true));
          const newConfirmBtn = document.getElementById('confirm-btn');
          const newCancelBtn = document.getElementById('cancel-btn');

          newConfirmBtn.addEventListener('click', () => {
              sequences = [];
              sequences.push(getNewSequenceData());
              sequences[0].patternName = "Pattern 1";
              activePatternId = null;
              showView('main');
              modal.classList.add('hidden');
              calculateTotalWorkoutTime();
          }, { once: true });

          newCancelBtn.addEventListener('click', () => {
              modal.classList.add('hidden');
          }, { once: true });
      };

      const showConfirmationModalForDelete = (indexToDelete) => {
          const modal = document.getElementById('confirmation-modal');
          const modalTitle = document.getElementById('modal-title');
          const modalText = document.getElementById('modal-text');
          const confirmBtn = document.getElementById('confirm-btn');
          const cancelBtn = document.getElementById('cancel-btn');

          modalTitle.textContent = 'Confirm Deletion';
          modalText.textContent = `Are you sure you want to delete pattern "${sequences[indexToDelete].patternName}"? This action cannot be undone.`;
          confirmBtn.textContent = 'Delete';
          confirmBtn.className = 'px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700';
          modal.classList.remove('hidden');

          confirmBtn.replaceWith(confirmBtn.cloneNode(true));
          cancelBtn.replaceWith(cancelBtn.cloneNode(true));
          const newConfirmBtn = document.getElementById('confirm-btn');
          const newCancelBtn = document.getElementById('cancel-btn');

          newConfirmBtn.addEventListener('click', () => {
              deleteSequence(indexToDelete);
              modal.classList.add('hidden');
              focusOnTop();
          }, { once: true });

          newCancelBtn.addEventListener('click', () => {
              modal.classList.add('hidden');
          }, { once: true });
      };


    // --- Workout Logic (unchanged from previous version) ---
    let currentPatternIndex = 0;
    let currentPatternTimer = null;
    let shotIntervalTimer = null;
    let flashTimer = null;
    let nextAnnouncementTimeout = null;
    let currentPatternShotCount = 0;
    let currentPatternTimeElapsed = 0;
    let currentShotOptions = [];
    let currentShotIndex = 0;
    let globalWorkoutTimeElapsed = 0;

    let isPaused = false;
    let pausedTimePassed = 0;
    let pausedEffectiveInterval = 0;
    let pausedRestTimeRemaining = 0;
    let pausedShotDisplayContent = '';

    let isToggleDebouncing = false;
    const DEBOUNCE_TIME = 300;

    function initAudioContext() {
        try {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') {
                    const resumeAudio = () => {
                        audioContext.resume().then(() => {
                            console.log('AudioContext resumed successfully.');
                            document.removeEventListener('click', resumeAudio);
                            document.removeEventListener('touchend', resumeAudio);
                        }).catch(error => console.error("Error resuming AudioContext:", error));
                    };
                    document.addEventListener('click', resumeAudio, { once: true, passive: true });
                    document.addEventListener('touchend', resumeAudio, { once: true, passive: true });
                }
            }
        } catch (error) {
            console.error("Failed to initialize AudioContext:", error);
        }
    }

    function initSpeechSynthesis() {
        if ('speechSynthesis' in window) {
            synth = window.speechSynthesis;
            const silentUtterance = new SpeechSynthesisUtterance('');
            silentUtterance.volume = 0;
            silentUtterance.onend = null;
            silentUtterance.onerror = null;
            try {
                synth.speak(silentUtterance);
                console.log('SpeechSynthesis initialized and wake-up utterance sent.');
            } catch (e) {
                console.warn('Initial silent utterance failed (may not be an issue if audio is already active):', e);
            }
        } else {
            console.warn('Speech Synthesis API not supported in this browser.');
        }
    }

    function speakSilent() {
        if (!synth || !isRoutineRunning || isPaused) {
            console.log('speakSilent: Conditions not met. isRoutineRunning:', isRoutineRunning, 'isPaused:', isPaused);
            return;
        }

        if (synth.speaking || synth.pending) {
            console.log('speakSilent: Synth busy, skipping silent utterance for now.');
            nextSilentUtteranceTimeout = setTimeout(() => {
                speakSilent();
            }, 100);
            return;
        }

        const utterance = new SpeechSynthesisUtterance('');
        utterance.volume = 0;
        utterance.lang = 'en-US';

        utterance.onend = () => {
            console.log('speakSilent: Silent utterance ended. Scheduling next...');
            if (isRoutineRunning && !isPaused) {
                nextSilentUtteranceTimeout = setTimeout(() => {
                    speakSilent();
                }, 50);
            }
        };

        utterance.onerror = (event) => {
            if (event.error !== 'interrupted') {
                console.error(`speakSilent: Silent speech synthesis error: ${event.error}`);
            } else {
                console.info('speakSilent: Silent SpeechSynthesisUtterance was interrupted, which is expected behavior.');
            }
            if (isRoutineRunning && !isPaused) {
                nextSilentUtteranceTimeout = setTimeout(() => {
                    speakSilent();
                }, 50);
            }
        };

        try {
            synth.speak(utterance);
            console.log('speakSilent: Silent utterance started.');
        } catch (e) {
            console.error("speakSilent: Error speaking silent utterance directly:", e);
            if (isRoutineRunning && !isPaused) {
                nextSilentUtteranceTimeout = setTimeout(() => {
                    speakSilent();
                }, 50);
            }
        }
    }

    function startSpeechKeepAlive() {
        if (!synth) {
            console.warn('startSpeechKeepAlive: SpeechSynthesis not available for keep-alive.');
            return;
        }
        stopSpeechKeepAlive();
        console.log('startSpeechKeepAlive: Initiating speech keep-alive chain...');
        speakSilent();
    }

    function stopSpeechKeepAlive() {
        if (nextSilentUtteranceTimeout) {
            clearTimeout(nextSilentUtteranceTimeout);
            nextSilentUtteranceTimeout = null;
            console.log('stopSpeechKeepAlive: Cleared nextSilentUtteranceTimeout.');
        }
        if (synth && (synth.speaking || synth.pending)) {
            synth.cancel();
            console.log('stopSpeechKeepAlive: Cancelled existing speech.');
        }
        console.log('stopSpeechKeepAlive: Speech keep-alive stopped and cancelled.');
    }

    function playTwoToneBeep() {
        try {
            if (!audioContext || audioContext.state !== 'running') {
                console.warn("playTwoToneBeep: AudioContext not ready for two-tone beep. State:", audioContext ? audioContext.state : 'null');
                return;
            }

            const duration = 0.15;
            const frequency1 = 800;
            const frequency2 = 1200;
            const volume = 4.0;

            const now = audioContext.currentTime;

            const oscillator1 = audioContext.createOscillator();
            const gainNode1 = audioContext.createGain();
            oscillator1.connect(gainNode1);
            gainNode1.connect(audioContext.destination);
            oscillator1.type = 'sine';
            oscillator1.frequency.setValueAtTime(frequency1, now);
            gainNode1.gain.setValueAtTime(volume, now);
            oscillator1.start(now);
            gainNode1.gain.exponentialRampToValueAtTime(0.00001, now + duration);
            oscillator1.stop(now + duration);

            const oscillator2 = audioContext.createOscillator();
            const gainNode2 = audioContext.createGain();
            oscillator2.connect(gainNode2);
            gainNode2.connect(audioContext.destination);
            oscillator2.type = 'sine';
            oscillator2.frequency.setValueAtTime(frequency2, now + duration);
            gainNode2.gain.setValueAtTime(volume, now + duration);
            oscillator2.start(now + duration);
            gainNode2.gain.exponentialRampToValueAtTime(0.00001, now + duration * 2);
            oscillator2.stop(now + duration * 2);
        } catch (error) {
            console.error("playTwoToneBeep: Error playing two-tone beep:", error);
        }
    }

    function speak(text) {
        if (!synth) {
            console.warn('speak: Speech Synthesis API not supported or not initialized.');
            return;
        }

        if (synth.speaking || synth.pending) {
            synth.cancel();
            if (nextSilentUtteranceTimeout) {
                clearTimeout(nextSilentUtteranceTimeout);
                nextSilentUtteranceTimeout = null;
            }
            if (nextAnnouncementTimeout) {
                clearTimeout(nextAnnouncementTimeout);
                nextAnnouncementTimeout = null;
            }
            console.log("speak: Cancelled existing speech for new audible message.");
        }

        if (text !== '') {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US';
            utterance.volume = 1;
            utterance.onend = () => {
                console.log(`speak: Finished speaking: "${text}". Re-initiating silent keep-alive.`);
                if (isRoutineRunning && !isPaused) {
                    startSpeechKeepAlive();
                }
            };
            utterance.onerror = (event) => {
                if (event.error !== 'interrupted') {
                    console.error(`speak: Audible speech synthesis error: ${event.error}`);
                } else {
                    console.info('speak: Audible SpeechSynthesisUtterance was interrupted, which is expected behavior.');
                }
                if (isRoutineRunning && !isPaused) {
                    startSpeechKeepAlive();
                }
            };
            try {
                synth.speak(utterance);
                console.log(`speak: Speaking: "${text}"`);
            } catch (e) {
                console.error("speak: Error speaking audible utterance:", e);
                if (isRoutineRunning && !isPaused) {
                    startSpeechKeepAlive();
                }
            }
        }
    }


    async function startWorkout() {
        console.log('startWorkout called. isPaused:', isPaused);
        if (sequences.length === 0) {
            showAlert('Workout Error', 'Please create at least one workout pattern first!');
            return;
        }

        // Save current active pattern state if in editor view
        if (!patternEditorContainer.classList.contains('hidden')) {
            saveCurrentPatternState();
        }

        initAudioContext();
        initSpeechSynthesis();

        isRoutineRunning = true;
        startSpeechKeepAlive();

        if (audioContext && audioContext.state === 'suspended') {
            try {
                await audioContext.resume();
                console.log('startWorkout: AudioContext resumed successfully before workout start.');
            } catch (error) {
                console.error("startWorkout: Error resuming AudioContext at startWorkout:", error);
                showAlert('Audio Error', 'Could not resume audio. Please try again.');
                stopWorkout();
                return;
            }
        } else if (audioContext && audioContext.state === 'closed') {
             initAudioContext();
             try {
                await audioContext.resume();
                console.log('startWorkout: AudioContext re-initialized and resumed successfully before workout start.');
             } catch (error) {
                console.error("startWorkout: Error re-initializing and resuming AudioContext at startWorkout:", error);
                showAlert('Audio Error', 'Could not re-initialize audio. Please try again.');
                stopWorkout();
                return;
             }
        }

        stopWorkoutBtn.innerHTML = `<span class="flex items-center justify-center">${STOP_ICON}</span>`;
        stopWorkoutBtn.onclick = stopWorkout;
        stopWorkoutBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'bg-gray-600', 'hover:bg-gray-700');
        stopWorkoutBtn.classList.add('bg-red-600', 'hover:bg-red-700');

        pauseResumeWorkoutBtn.innerHTML = `<span class="flex items-center justify-center">${PAUSE_ICON}</span>`;
        pauseResumeWorkoutBtn.onclick = togglePauseResume;
        pauseResumeWorkoutBtn.classList.remove('hidden');

        showView('workout');
        currentPatternIndex = 0;
        globalWorkoutTimeElapsed = 0;
        isPaused = false;
        runCurrentPattern();
    }

    function stopWorkout() {
        console.log('stopWorkout: Stopping workout...');
        if (currentPatternTimer) {
            clearInterval(currentPatternTimer);
            currentPatternTimer = null;
            console.log('stopWorkout: Cleared currentPatternTimer.');
        }
        if (shotIntervalTimer) {
            clearInterval(shotIntervalTimer);
            shotIntervalTimer = null;
            console.log('stopWorkout: Cleared shotIntervalTimer.');
        }
        if (flashTimer) {
            clearTimeout(flashTimer);
            flashTimer = null;
            console.log('stopWorkout: Cleared flashTimer.');
        }
        if (nextAnnouncementTimeout) {
            clearTimeout(nextAnnouncementTimeout);
            nextAnnouncementTimeout = null;
            console.log('stopWorkout: Cleared nextAnnouncementTimeout.');
        }

        document.body.classList.remove('bg-red-500');
        isRoutineRunning = false;
        stopSpeechKeepAlive();
        synth.cancel();
        showView('main'); // Return to main view
        calculateTotalWorkoutTime();
        console.log('stopWorkout: Workout stopped.');
    }

    function togglePauseResume() {
        if (isToggleDebouncing) {
            console.log('togglePauseResume: Debouncing, ignoring click.');
            return;
        }
        isToggleDebouncing = true;
        setTimeout(() => {
            isToggleDebouncing = false;
        }, DEBOUNCE_TIME);

        console.log('togglePauseResume called. isPaused (before toggle):', isPaused);
        if (isPaused) {
            resumeWorkout();
        } else {
            pauseWorkout();
        }
    }

    function pauseWorkout() {
        console.log('pauseWorkout: Pausing workout...');
        isPaused = true;

        pausedShotDisplayContent = currentShotDisplay.textContent;

        if (currentPatternTimer) {
            console.log('pauseWorkout: Clearing currentPatternTimer:', currentPatternTimer);
            clearInterval(currentPatternTimer);
            currentPatternTimer = null;
        }
        if (shotIntervalTimer) {
            console.log('pauseWorkout: Clearing shotIntervalTimer (rest):', shotIntervalTimer);
            clearInterval(shotIntervalTimer);
            shotIntervalTimer = null;
        }
        if (flashTimer) {
            console.log('pauseWorkout: Clearing flashTimer:', flashTimer);
            clearTimeout(flashTimer);
            flashTimer = null;
        }
        if (nextAnnouncementTimeout) {
            console.log('pauseWorkout: Clearing nextAnnouncementTimeout:', nextAnnouncementTimeout);
            clearTimeout(nextAnnouncementTimeout);
            nextAnnouncementTimeout = null;
        }
        stopSpeechKeepAlive();

        document.body.classList.remove('bg-red-500');
        synth.cancel();

        currentShotDisplay.textContent = 'Paused';
        progressBar.style.width = `${(pausedTimePassed / pausedEffectiveInterval) * 100}%`;
        console.log('pauseWorkout: Workout paused. pausedTimePassed:', pausedTimePassed, 'pausedEffectiveInterval:', pausedEffectiveInterval, 'pausedRestTimeRemaining:', pausedRestTimeRemaining);
    }

    function resumeWorkout() {
        console.log('resumeWorkout: Resuming workout...');
        isPaused = false;
        pauseResumeWorkoutBtn.innerHTML = `<span class="flex items-center justify-center">${PAUSE_ICON}</span>`;
        startSpeechKeepAlive();

        const currentPattern = sequences[currentPatternIndex];

        if (pausedShotDisplayContent === 'Rest!') {
            console.log('resumeWorkout: Resuming Rest! period.');
            let restRemaining = pausedRestTimeRemaining;
            currentShotDisplay.textContent = 'Rest!';

            shotIntervalTimer = setInterval(() => {
                console.log('Rest interval tick. isPaused:', isPaused, 'shotIntervalTimer ID:', shotIntervalTimer);
                if (isPaused) {
                    console.log('Rest interval tick: Paused, clearing shotIntervalTimer and returning.');
                    clearInterval(shotIntervalTimer);
                    shotIntervalTimer = null;
                    return;
                }
                restRemaining--;
                globalWorkoutTimeElapsed++;
                pausedRestTimeRemaining = restRemaining;
                console.log('Rest remaining:', restRemaining);

                if (restRemaining <= 0) {
                    console.log('Rest period ended. Moving to next pattern.');
                    clearInterval(shotIntervalTimer);
                    shotIntervalTimer = null;
                    currentPatternIndex++;
                    runCurrentPattern();
                }
            }, 1000);
            console.log('resumeWorkout: New shotIntervalTimer set for rest:', shotIntervalTimer);
        } else {
            console.log('resumeWorkout: Resuming Shot Interval.');
            startShotInterval(currentPattern, pausedTimePassed, pausedEffectiveInterval, pausedShotDisplayContent);
        }
    }


    function runCurrentPattern() {
        console.log('runCurrentPattern called. isPaused:', isPaused);
        if (isPaused) {
            console.log('runCurrentPattern: PAUSED, returning immediately.');
            return;
        }

        if (currentPatternIndex >= sequences.length) {
            handleWorkoutCompletion();
            return;
        }

        const currentPattern = sequences[currentPatternIndex];
        currentPatternNameDisplay.textContent = currentPattern.patternName;
        currentPatternNameDisplay.classList.remove('hidden');

        currentShotOptions = currentPattern.shotOptions.split('\n').filter(option => option.trim() !== '');

        if (currentShotOptions.length === 0) {
            currentShotDisplay.textContent = 'No shots defined for this pattern';
            endPattern(currentPattern);
            return;
        }

        if (currentPattern.seriesOrder === 'randomized') {
            shuffleArray(currentShotOptions);
        }
        currentPatternShotCount = 0;
        currentPatternTimeElapsed = 0;

        if (currentPattern.announceShots && currentPattern.introMessage.trim()) {
            speak(currentPattern.introMessage);
        }

        const firstShotToDisplay = currentShotOptions[0];
        currentShotIndex = 1 % currentShotOptions.length;
        if (currentPattern.seriesOrder === 'randomized' && currentShotIndex === 0) {
            shuffleArray(currentShotOptions);
        }
        startShotInterval(currentPattern, 0, -1, firstShotToDisplay);
    }

    function startShotInterval(pattern, initialTimePassed = 0, totalInterval = -1, shotToDisplayAtStart = null) {
        console.log('startShotInterval called. isPaused:', isPaused);
        if (isPaused) {
            console.log('startShotInterval: PAUSED, returning immediately.');
            return;
        }

        if (currentPatternTimer) {
            clearInterval(currentPatternTimer);
            currentPatternTimer = null;
            console.log('startShotInterval: Cleared existing currentPatternTimer.');
        }
        if (shotIntervalTimer) {
            clearInterval(shotIntervalTimer);
            shotIntervalTimer = null;
            console.log('startShotInterval: Cleared existing shotIntervalTimer.');
        }
        if (flashTimer) {
            clearTimeout(flashTimer);
            flashTimer = null;
            console.log('startShotInterval: Cleared existing flashTimer.');
        }
        if (nextAnnouncementTimeout) {
            clearTimeout(nextAnnouncementTimeout);
            nextAnnouncementTimeout = null;
            console.log('startShotInterval: Cleared existing nextAnnouncementTimeout.');
        }
        if (nextSilentUtteranceTimeout) {
            clearTimeout(nextSilentUtteranceTimeout);
            nextSilentUtteranceTimeout = null;
            console.log('startShotInterval: Cleared existing nextSilentUtteranceTimeout.');
        }


        const baseInterval = parseFloat(pattern.shotInterval);
        const randomOffset = parseFloat(pattern.randomOffset);
        const nextShotAnnouncementTime = parseFloat(pattern.nextShotAnnouncement);

        let effectiveInterval = (totalInterval > 0) ? totalInterval : (baseInterval + (Math.random() * randomOffset));
        let timePassed = initialTimePassed;

        pausedEffectiveInterval = effectiveInterval;
        pausedTimePassed = initialTimePassed;

        const currentDisplayedShot = (shotToDisplayAtStart !== null) ? shotToDisplayAtStart : pausedShotDisplayContent;
        currentShotDisplay.textContent = currentDisplayedShot;

        if (initialTimePassed === 0) {
            playTwoToneBeep();
            flashScreenRed();
        }

        let announcementSpokenForThisInterval = false;
        if (pattern.announceShots && nextShotAnnouncementTime > 0) {
            if (initialTimePassed === 0) { // Schedule if starting fresh
                nextAnnouncementTimeout = setTimeout(() => {
                    if (!isPaused && currentShotDisplay.textContent === currentDisplayedShot && currentDisplayedShot.trim() !== '' && currentDisplayedShot !== 'No shots defined for this pattern') {
                        speak(currentDisplayedShot);
                        announcementSpokenForThisInterval = true;
                    }
                }, nextShotAnnouncementTime * 1000);
            } else if (initialTimePassed < nextShotAnnouncementTime) { // If resuming, reschedule if not already passed
                 nextAnnouncementTimeout = setTimeout(() => {
                    if (!isPaused && currentShotDisplay.textContent === currentDisplayedShot && currentDisplayedShot.trim() !== '' && currentDisplayedShot !== 'No shots defined for this pattern') {
                        speak(currentDisplayedShot);
                        announcementSpokenForThisInterval = true;
                    }
                }, (nextShotAnnouncementTime - initialTimePassed) * 1000);
            } else { // If resuming and already passed announcement time
                announcementSpokenForThisInterval = true;
            }
        }


        function timerTick() {
            if (isPaused) {
                clearInterval(currentPatternTimer);
                currentPatternTimer = null;
                return;
            }
            timePassed += 0.1;
            currentPatternTimeElapsed += 0.1;
            globalWorkoutTimeElapsed += 0.1;

            pausedTimePassed = timePassed;

            const progress = (timePassed / effectiveInterval) * 100;
            progressBar.style.width = `${progress}%`;

            if (pattern.announceShots && !announcementSpokenForThisInterval &&
                nextShotAnnouncementTime > 0 &&
                timePassed >= nextShotAnnouncementTime &&
                timePassed < effectiveInterval
            ) {
                if (currentDisplayedShot && currentDisplayedShot.trim() !== '' && currentDisplayedShot !== 'No shots defined for this pattern') {
                    speak(currentDisplayedShot);
                    announcementSpokenForThisInterval = true;
                }
            }

            if (timePassed >= effectiveInterval) {
                clearInterval(currentPatternTimer);
                currentPatternTimer = null;
                currentPatternShotCount++;

                const nextShotToDisplay = currentShotOptions[currentShotIndex];
                currentShotIndex = (currentShotIndex + 1) % currentShotOptions.length;
                if (pattern.seriesOrder === 'randomized' && currentShotIndex === 0) {
                    shuffleArray(currentShotOptions);
                }

                if (shouldEndPattern(pattern)) {
                    endPattern(pattern);
                    return;
                }
                startShotInterval(pattern, 0, -1, nextShotToDisplay);
            }
        }

        currentPatternTimer = setInterval(timerTick, 100);
    }


    function shouldEndPattern(pattern) {
        if (pattern.limitType === 'shot' && currentPatternShotCount >= pattern.patternLimit) {
            return true;
        }
        if (pattern.limitType === 'time' && currentPatternTimeElapsed >= pattern.patternLimit) {
            return true;
        }
        return false;
    }

    function endPattern(pattern) {
        if (currentPatternTimer) { clearInterval(currentPatternTimer); currentPatternTimer = null; }
        if (shotIntervalTimer) { clearInterval(shotIntervalTimer); shotIntervalTimer = null; }
        if (flashTimer) { clearTimeout(flashTimer); flashTimer = null; }
        if (nextAnnouncementTimeout) { clearTimeout(nextAnnouncementTimeout); nextAnnouncementTimeout = null; }
        document.body.classList.remove('bg-red-500');
        synth.cancel();

        if (pattern.announceShots && pattern.outroMessage.trim()) {
            speak(pattern.outroMessage);
        }

        const postRestTime = parseInt(pattern.postSequenceRest);
        if (postRestTime > 0) {
            currentShotDisplay.textContent = "Rest!";
            progressBar.style.width = '100%';

            let restRemaining = postRestTime;
            pausedRestTimeRemaining = postRestTime;

            shotIntervalTimer = setInterval(() => {
                if (isPaused) {
                    clearInterval(shotIntervalTimer);
                    shotIntervalTimer = null;
                    return;
                }
                restRemaining--;
                globalWorkoutTimeElapsed++;
                pausedRestTimeRemaining = restRemaining;

                if (restRemaining <= 0) {
                    clearInterval(shotIntervalTimer);
                    shotIntervalTimer = null;
                    currentPatternIndex++;
                    runCurrentPattern();
                }
            }, 1000);
        } else {
            currentPatternIndex++;
            runCurrentPattern();
        }
    }

    function handleWorkoutCompletion() {
        if (currentPatternTimer) { clearInterval(currentPatternTimer); currentPatternTimer = null; }
        if (shotIntervalTimer) { clearInterval(shotIntervalTimer); shotIntervalTimer = null; }
        if (flashTimer) { clearTimeout(flashTimer); flashTimer = null; }
        if (nextAnnouncementTimeout) { clearTimeout(nextAnnouncementTimeout); nextAnnouncementTimeout = null; }
        document.body.classList.remove('bg-red-500');

        isRoutineRunning = false;
        stopSpeechKeepAlive();
        synth.cancel();

        currentShotDisplay.textContent = 'Done';
        progressBar.style.width = '100%';

        pauseResumeWorkoutBtn.innerHTML = `<span class="flex items-center justify-center">${REPLAY_ICON}</span>`;
        pauseResumeWorkoutBtn.onclick = null;
        pauseResumeWorkoutBtn.addEventListener('click', () => {
            currentPatternIndex = 0;
            startWorkout();
        }, { once: true });
        pauseResumeWorkoutBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
        pauseResumeWorkoutBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');

        stopWorkoutBtn.innerHTML = `<span class="flex items-center justify-center">${EXIT_ICON}</span>`;
        stopWorkoutBtn.onclick = null;
        stopWorkoutBtn.addEventListener('click', stopWorkout, { once: true });
        stopWorkoutBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
        stopWorkoutBtn.classList.add('bg-gray-600', 'hover:bg-gray-700');
    }

    function flashScreenRed() {
        if (isPaused) { return; }
        document.body.classList.add('bg-red-500');
        void document.body.offsetWidth;
        flashTimer = setTimeout(() => {
            document.body.classList.remove('bg-red-500');
            flashTimer = null;
        }, 150);
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

      // --- EVENT LISTENERS ---

      // Global click listener to turn off modes if an unrelated element is clicked
      document.addEventListener('click', (e) => {
          if (isMoveModeOn || isDeleteModeOn) {
              if (
                  !movePatternToggleButton.contains(e.target) &&
                  !deletePatternToggleButton.contains(e.target) &&
                  !patternsAccordionContainer.contains(e.target) &&
                  !e.target.closest('#confirmation-modal') &&
                  !e.target.closest('#alert-modal') &&
                  e.target !== startWorkoutButton &&
                  !startWorkoutButton.contains(e.target) &&
                  !workoutViewContainer.contains(e.target)
              ) {
                  setInteractionMode(null);
              }
          }
      });


      // Main Action Buttons (New, Move Toggle, Delete Toggle)
      newPatternBtn.addEventListener('click', () => {
        addSequence();
      });

      movePatternToggleButton.addEventListener('click', () => {
          setInteractionMode(isMoveModeOn ? null : 'move');
      });

      deletePatternToggleButton.addEventListener('click', () => {
          setInteractionMode(isDeleteModeOn ? null : 'delete');
      });


      // Event delegation for accordion container clicks (List View)
      patternsAccordionContainer.addEventListener('click', (e) => {
          const accordionItem = e.target.closest('.accordion-item');
          if (!accordionItem) return;

          const patternId = parseFloat(accordionItem.dataset.patternId);
          const patternIndex = sequences.findIndex(p => p.id === patternId);
          if (patternIndex === -1) return;

          if (isMoveModeOn) {
              if (e.target.closest('.chevron-up-toggle')) {
                  movePattern(patternIndex, 'up');
              } else if (e.target.closest('.chevron-down-toggle')) {
                  movePattern(patternIndex, 'down');
              }
              e.stopPropagation();
          } else if (isDeleteModeOn) {
              if (e.target.closest('.delete-toggle')) {
                  showConfirmationModalForDelete(patternIndex);
              }
              e.stopPropagation();
          }
          // Normal mode: handled by the specific event listener on accordion header in renderAccordionView
          // This allows the general accordion header click to navigate to editor
      });


      // Back to List button in editor
      document.getElementById('back-to-list-btn').addEventListener('click', () => {
          saveCurrentPatternState(); // Save changes from editor
          activePatternId = null; // Clear active pattern
          showView('main'); // Go back to main accordion view
      });

      // Pattern Name Edit in Editor
      document.getElementById('editor-pattern-name-display').addEventListener('click', editPatternNameInEditor);


      // Event listeners for inputs/changes within the currently rendered editor screen
      activePatternEditorContent.addEventListener('input', (e) => {
          // No need to check activePatternId here as this listener is only for the visible editor
          if (e.target.id === 'editor-shot-options-input') updateEditorShotOptionsDisplay();
          else if (e.target.id === 'editor-intro-message-input' || e.target.id === 'editor-outro-message-input' || e.target.id === 'editor-announce-shots-checkbox') updateEditorNarrationDisplay();
          else if (e.target.id === 'editor-shot-interval-slider' || e.target.id === 'editor-random-offset-slider' || e.target.id === 'editor-next-shot-announcement-slider') {
              updateEditorIntervalDisplay();
              if (e.target.id === 'editor-shot-interval-slider') {
                handleEditorAnnounceShotsChange();
                const currentPattern = sequences.find(p => p.id === activePatternId);
                if (currentPattern && currentPattern.limitType === 'time') {
                    handleEditorLimitTypeChange(); // Re-evaluate limits if time-based and interval changes
                }
              }
          }
          else if (e.target.id === 'editor-pattern-limit-slider') updateEditorLimitsDisplay();
          else if (e.target.id === 'editor-post-sequence-rest-slider') updateEditorPostRestDisplay();
          saveCurrentPatternState();
      });

      activePatternEditorContent.addEventListener('change', (e) => {
          // No need to check activePatternId here as this listener is only for the visible editor
          if (e.target.id === 'editor-limit-type-select') {
              handleEditorLimitTypeChange();
          } else if (e.target.name === 'editorSeriesOrder') {
              updateEditorSequencingDisplay();
          } else if (e.target.id === 'editor-announce-shots-checkbox') {
              handleEditorAnnounceShotsChange();
          }
          saveCurrentPatternState();
      });

      // Individual pattern action buttons in the editor
      document.getElementById('clone-btn').addEventListener('click', cloneSequence);
      document.getElementById('import-btn').addEventListener('click', importPatternConfig);
      document.getElementById('save-btn').addEventListener('click', savePatternConfig);
      document.getElementById('reset-btn').addEventListener('click', resetCurrentSequence);


      // Global buttons for all patterns
      document.getElementById('load-all-btn').addEventListener('click', loadAllPatterns);
      document.getElementById('save-all-btn').addEventListener('click', saveAllPatterns);
      document.getElementById('reset-all-btn').addEventListener('click', clearAllPatterns);

      // --- Workout Buttons Event Listeners ---
      startWorkoutButton.addEventListener('click', startWorkout);
      pauseResumeWorkoutBtn.addEventListener('click', togglePauseResume);


      // --- INITIALIZATION ---
      const initialize = () => {
        if (sequences.length === 0) {
            sequences.push(getNewSequenceData());
            sequences[0].patternName = "Pattern 1";
        }
        activePatternId = null; // Start with no pattern active in editor
        showView('main'); // Start with the main accordion list view
        calculateTotalWorkoutTime();

        initAudioContext();
        initSpeechSynthesis();
      };

      initialize();
    });
  </script>
</body>
</html>

